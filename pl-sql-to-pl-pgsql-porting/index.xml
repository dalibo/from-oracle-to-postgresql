<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>PL/SQL to PL/pgSQL porting on From Oracle to PostgreSQL</title><link>https://example.com/pl-sql-to-pl-pgsql-porting/</link><description>Recent content in PL/SQL to PL/pgSQL porting on From Oracle to PostgreSQL</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://example.com/pl-sql-to-pl-pgsql-porting/index.xml" rel="self" type="application/rss+xml"/><item><title>Porting procedures and functions</title><link>https://example.com/porting-procedures-and-functions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/porting-procedures-and-functions/</guid><description>Porting procedures and functions # Functions declaration # Both of Oracle and PostgreSQL allow functions and procedures creation, also called routines in PostgreSQL&amp;rsquo;s documentation. Procedures can be invoked by CALL word, while functions are called by SELECT or PERFORM.</description></item><item><title>Triggers conversion</title><link>https://example.com/triggers-conversion/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/triggers-conversion/</guid><description>Triggers conversion # Structure of a trigger # In Oracle, a trigger declaration embeds the triggers code. In PostgreSQL, a trigger and a trigger function are two distinct objects: the trigger calls a trigger function depending on the events it must act upon.</description></item><item><title>Control structures</title><link>https://example.com/control-structures/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/control-structures/</guid><description>Control structures # Loops and control structures don&amp;rsquo;t require a lot of work, except for the GOTO and FORALL instructions.
FOR REVERSE loop # The FOR ... REVERSE has also the peculiarity of needing to revers the min and max boundaries in FOR .</description></item><item><title>PL/SQL code conversion</title><link>https://example.com/pl-sql-code-conversion/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/pl-sql-code-conversion/</guid><description>PL/SQL code conversion # Empty strings and NULL values # For Oracle, an empty string is NULL too. PostgreSQL makes a difference: IS NULL and empty are different.
Some queries working with Oracle may not work as expected if directly copied.</description></item><item><title>Cursors</title><link>https://example.com/cursors/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/cursors/</guid><description>Cursors # The cursors variable&amp;rsquo;s notation is different in Oracle and PostgreSQL.
Cursors declaration # With Oracle, a cursor is declared this way: CURSOR mycursor. This has to be reverted with PostgreSQL: mycursor CURSOR.</description></item><item><title>PL/SQL specificities</title><link>https://example.com/pl-sql-specificities/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/pl-sql-specificities/</guid><description>PL/SQL specificities # Autonomous transactions # We often find PRAGMA associated with autonomous transactions in PL/SQL. This last notion does not exist in PostgreSQL.
It is possible to emulate autonomous transactions through a dblink, but it is a particularly counter-efficient solution that consumes resources.</description></item><item><title>Oracle's packages</title><link>https://example.com/oracles-packages/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/oracles-packages/</guid><description>Oracle&amp;rsquo;s packages # Proprietary packages have few or no equivalents in PostgreSQL. It is possible rewrite them entirely or to rely on free contributions to obtain behavior close to those proposed by Oracle.</description></item></channel></rss>