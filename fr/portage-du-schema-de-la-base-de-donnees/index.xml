<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Portage du schéma on Porter Oracle vers PostgreSQL</title><link>https://dalibo.github.io/from-oracle-to-postgresql/fr/portage-du-schema-de-la-base-de-donnees/</link><description>Recent content in Portage du schéma on Porter Oracle vers PostgreSQL</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://dalibo.github.io/from-oracle-to-postgresql/fr/portage-du-schema-de-la-base-de-donnees/index.xml" rel="self" type="application/rss+xml"/><item><title>Correspondance des types de données</title><link>https://dalibo.github.io/from-oracle-to-postgresql/fr/correspondance-des-types-de-donnees/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dalibo.github.io/from-oracle-to-postgresql/fr/correspondance-des-types-de-donnees/</guid><description>Correspondance des types de données # Le SGBD Oracle ne supporte pas l&amp;rsquo;ensemble des types de données spécifiés par la norme SQL. Il s&amp;rsquo;agit notamment des types numériques natifs tels que SMALLINT, INT et BIGINT.</description></item><item><title>Reprise des tables</title><link>https://dalibo.github.io/from-oracle-to-postgresql/fr/reprise-des-tables/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dalibo.github.io/from-oracle-to-postgresql/fr/reprise-des-tables/</guid><description>Reprise des tables # La définition des tables est quasiment identique pour les deux SGBD à la différence près que PostgreSQL n&amp;rsquo;a pas de table temporaire globale. Les tables temporaires sont privées à une session.</description></item><item><title>Reprise des vues</title><link>https://dalibo.github.io/from-oracle-to-postgresql/fr/reprise-des-vues/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dalibo.github.io/from-oracle-to-postgresql/fr/reprise-des-vues/</guid><description>Reprise des vues # Les vues simples sont portées sans difficultés sur PostgreSQL.
PostgreSQL supporte également les vues que l&amp;rsquo;on peut mettre à jour (updatable views), y compris avec la clause WITH CHECK OPTION qui permet de s&amp;rsquo;assurer que des données insérées ou mises à jour dans la vue satisfont toujours les éventuelles conditions de sélection de cette vue.</description></item><item><title>Reprise des séquences</title><link>https://dalibo.github.io/from-oracle-to-postgresql/fr/reprise-des-sequences/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dalibo.github.io/from-oracle-to-postgresql/fr/reprise-des-sequences/</guid><description>Reprise des séquences # La reprise des séquences ne nécessite pas un travail important. Les séquences sont implémentées de la même façon dans PostgreSQL et dans Oracle. Cependant, certains points nécessitent un peu d&amp;rsquo;attention.</description></item><item><title>Reprise des index</title><link>https://dalibo.github.io/from-oracle-to-postgresql/fr/reprise-des-index/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dalibo.github.io/from-oracle-to-postgresql/fr/reprise-des-index/</guid><description>Reprise des index # Pour les index, seule la forme BTREE correspond. Les autres types d&amp;rsquo;index d&amp;rsquo;Oracle ne sont pas implémentées mais PostgreSQL dispose lui-aussi d&amp;rsquo;autres types d&amp;rsquo;index. Quoiqu&amp;rsquo;il en soit, la plupart des index utilisés sont des index de type BTREE car c&amp;rsquo;est la méthode par défaut utilisée lors de la création d&amp;rsquo;un index.</description></item><item><title>Reprise des partitions</title><link>https://dalibo.github.io/from-oracle-to-postgresql/fr/reprise-des-partitions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dalibo.github.io/from-oracle-to-postgresql/fr/reprise-des-partitions/</guid><description>Reprise des partitions # PostgreSQL dispose d&amp;rsquo;un partitionnement déclaratif depuis la version 10, qui ne cesse de s&amp;rsquo;améliorer de version majeure en version majeure. Le type du partitionnement est décisif au moment de la définition du modèle, car il est très coûteux de le changer au moment de la vie des données.</description></item></channel></rss>