<!doctype html><html lang=fr dir=ltr><head><meta name=generator content="Hugo 0.106.0"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Correspondance des types de données # Le SGBD Oracle ne supporte pas l&rsquo;ensemble des types de données spécifiés par la norme SQL. Il s&rsquo;agit notamment des types numériques natifs tels que SMALLINT, INT et BIGINT."><meta name=theme-color content="#FFFFFF"><meta property="og:title" content="Correspondance des types de données"><meta property="og:description" content="Correspondance des types de données # Le SGBD Oracle ne supporte pas l&rsquo;ensemble des types de données spécifiés par la norme SQL. Il s&rsquo;agit notamment des types numériques natifs tels que SMALLINT, INT et BIGINT."><meta property="og:type" content="article"><meta property="og:url" content="https://example.com/fr/correspondance-des-types-de-donnees/"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2022-11-21T17:42:55+01:00"><meta property="og:site_name" content="Porter Oracle vers PostgreSQL"><title>Correspondance des types de données</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=alternate hreflang=en href=https://example.com/datatypes/ title=Datatypes><link rel=stylesheet href=/book.min.a0b1bf814d7fc28217ec0eea7c47371480fb4f325cec9eb1ae1aa1097d715ec7.css integrity="sha256-oLG/gU1/woIX7A7qfEc3FID7TzJc7J6xrhqhCX1xXsc="><script defer src=/fr.search.min.5d63b8891e1dc2263e2b13f848788122e3355a2ceb861e5d51f75a06ead1be44.js integrity="sha256-XWO4iR4dwiY+KxP4SHiBIuM1Wizrhh5dUfdaBurRvkQ="></script>
<script defer src=/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js integrity="sha256-b2+Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC+NdcPIvZhzk="></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a href=/fr><img src=/images/logo.png alt=Logo><span>Porter Oracle vers PostgreSQL</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Rechercher aria-label=Rechercher maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=https://example.com/fr/differences-generales-entre-oracle-et-postgresql/>Différences générales</a><ul></ul></li><li><input type=checkbox id=section-88c4d5ca464ed2de3d87c4f315803bbb class=toggle checked>
<label for=section-88c4d5ca464ed2de3d87c4f315803bbb class="flex justify-between"><a href=https://example.com/fr/portage-du-schema-de-la-base-de-donnees/>Portage du schéma</a></label><ul><li><a href=https://example.com/fr/correspondance-des-types-de-donnees/ class=active>Correspondance des types de données</a></li><li><a href=https://example.com/fr/reprise-des-tables/>Reprise des tables</a></li><li><a href=https://example.com/fr/reprise-des-vues/>Reprise des vues</a></li><li><a href=https://example.com/fr/reprise-des-sequences/>Reprise des séquences</a></li><li><a href=https://example.com/fr/reprise-des-index/>Reprise des index</a></li><li><a href=https://example.com/fr/reprise-des-partitions/>Reprise des partitions</a></li></ul></li><li><input type=checkbox id=section-b7e37e1862e6db598e5e41747363d74a class=toggle>
<label for=section-b7e37e1862e6db598e5e41747363d74a class="flex justify-between"><a href=https://example.com/fr/portage-des-requetes-sql/>Portage des requêtes SQL</a></label><ul><li><a href=https://example.com/fr/specificites-des-types-de-donnees/>Spécificités des types de données</a></li><li><a href=https://example.com/fr/jointures/>Jointures</a></li><li><a href=https://example.com/fr/expressions-conditionnelles/>Expressions conditionnelles</a></li><li><a href=https://example.com/fr/traitement-des-hierarchies/>Traitement des hiérarchies</a></li><li><a href=https://example.com/fr/gestion-des-transactions/>Gestion des transactions</a></li></ul></li><li><input type=checkbox id=section-cfaa4d420be7e860c2f111a313f9a252 class=toggle>
<label for=section-cfaa4d420be7e860c2f111a313f9a252 class="flex justify-between"><a href=https://example.com/fr/portage-du-code-pl-sql-vers-pl-pgsql/>Portage du code PL/SQL vers PL/pgSQL</a></label><ul><li><a href=https://example.com/fr/portage-des-procedures-et-fonctions/>Portage des procédures et fonctions</a></li><li><a href=https://example.com/fr/portage-des-triggers/>Portage des triggers</a></li><li><a href=https://example.com/fr/structures-de-controles/>Structures de contrôles</a></li><li><a href=https://example.com/fr/reprise-du-code-pl-sql/>Reprise du code PL/SQL</a></li><li><a href=https://example.com/fr/curseurs/>Curseurs</a></li><li><a href=https://example.com/fr/specificites-pl-sql/>Spécificités PL/SQL</a></li><li><a href=https://example.com/fr/packages-proprietaires/>Packages propriétaires</a></li></ul></li><li><a href=https://example.com/fr/nous-contacter/>Nous contacter</a><ul></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Correspondance des types de données</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><ul><li><a href=#correspondance-des-types-de-données>Correspondance des types de données</a><ul><li><a href=#traitement-des-booléens>Traitement des booléens</a></li><li><a href=#différences-sur-les-types-caractères>Différences sur les types caractères</a></li><li><a href=#encodage-des-caractères-et-collationnement>Encodage des caractères et collationnement</a></li><li><a href=#type-de-données-date-et-heure>Type de données date et heure</a></li><li><a href=#traitement-des-types-composites>Traitement des types composites</a></li></ul></li></ul></li></ul></nav></aside></header><article class=markdown><h2 id=correspondance-des-types-de-données>Correspondance des types de données
<a class=anchor href=#correspondance-des-types-de-donn%c3%a9es>#</a></h2><p>Le SGBD Oracle ne supporte pas l&rsquo;ensemble des types de données spécifiés par la
norme SQL. Il s&rsquo;agit notamment des types numériques <em>natifs</em> tels que <code>SMALLINT</code>,
<code>INT</code> et <code>BIGINT</code>. Le type <code>VARCHAR2</code> est également une spécificité Oracle,
notamment dans sa gestion de la valeur NULL. De plus, un certain nombre de types
spécifiques à Oracle sont nommés différemment dans PostgreSQL.</p><table><thead><tr><th>Types Oracle</th><th>Types PostgreSQL</th></tr></thead><tbody><tr><td>varchar2, nchar2, nvarchar2, nclob</td><td>varchar ou text</td></tr><tr><td>clob, long</td><td>varchar ou text</td></tr><tr><td>blob, raw, long raw</td><td>bytea</td></tr><tr><td>number</td><td>numeric, integer, bigint, smallint, real, double precision</td></tr><tr><td>date</td><td>date ou timestamp</td></tr><tr><td>binary float</td><td>real</td></tr><tr><td>binary double</td><td>double precision</td></tr></tbody></table><h3 id=traitement-des-booléens>Traitement des booléens
<a class=anchor href=#traitement-des-bool%c3%a9ens>#</a></h3><p>Oracle ne possède pas de type de données représentant des booléens. De ce fait,
une chaîne de caractères est souvent utilisée. Ora2Pg permet de convertir des
données représentant un booléen vers PostgreSQL.</p><p>Par ailleurs, l&rsquo;absence de type booléen dans Oracle entraîne des difficultés avec
des ORM tel que Hibernate. En effet, la colonne configurée comme un booléen dans
l&rsquo;ORM sera représenté physiquement dans la base Oracle comme un type entier ou un
type texte. Or, si le portage de la base de données ne tient pas compte de cette
problématique, l&rsquo;ORM cherchera un booléen dans la base PostgreSQL mais trouvera
le type équivalent à celui de la base Oracle.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> <span style=color:#66d9ef>true</span> <span style=color:#66d9ef>AND</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span><span style=color:#75715e>-- -[ RECORD 1 ]
</span></span></span><span style=display:flex><span><span style=color:#75715e>-- ?column? | f
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> <span style=color:#66d9ef>true</span> <span style=color:#66d9ef>OR</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span><span style=color:#75715e>-- -[ RECORD 1 ]
</span></span></span><span style=display:flex><span><span style=color:#75715e>-- ?column? | t
</span></span></span></code></pre></div><h3 id=différences-sur-les-types-caractères>Différences sur les types caractères
<a class=anchor href=#diff%c3%a9rences-sur-les-types-caract%c3%a8res>#</a></h3><p>Oracle implémente un type de données spécifique, <code>VARCHAR2</code>. Parmi ses spécificités,
il confond la chaîne vide et la valeur <code>NULL</code>, ce qui est contraire à la norme SQL.
Ainsi, sous Oracle, une comparaison avec <code>''</code> correspond à <code>IS NULL</code>.</p><p>PostgreSQL, quant à lui, propose un type de données <code>VARCHAR</code> qui est conforme à
la norme. La comparaison avec <code>''</code> est distincte de <code>IS NULL</code>. Ce type <code>VARCHAR</code>
est limitée à 1 Go. PostgreSQL propose également un type <code>text</code> qui est équivalent à
un <code>VARCHAR</code> sans limite de taille.</p><p>Il faut s&rsquo;attendre aussi à des différences de comportement lors de la comparaison
entre types <code>CHAR</code> et <code>VARCHAR</code>. C&rsquo;est une zone assez floue de la norme SQL, et
chaque moteur a sa propre interprétation.</p><p>Lors de la comparaison de ces deux types, PostgreSQL choisit de convertir le
<code>VARCHAR</code> en <code>CHAR</code>. Il applique ensuite une comparaison avec du remplissage
(<em>padding</em>) à droite par des blancs jusqu&rsquo;à la longueur du <code>CHAR(x)</code>.</p><p>Par exemple :</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> <span style=color:#e6db74>&#39;foo&#39;</span>::CHAR(<span style=color:#ae81ff>5</span>)<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;foo &#39;</span>::VARCHAR(<span style=color:#ae81ff>5</span>);
</span></span><span style=display:flex><span><span style=color:#75715e>--  ?column? 
</span></span></span><span style=display:flex><span><span style=color:#75715e>-- ----------
</span></span></span><span style=display:flex><span><span style=color:#75715e>--  t
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> <span style=color:#e6db74>&#39;foo &#39;</span>::CHAR(<span style=color:#ae81ff>5</span>)<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;foo&#39;</span>::VARCHAR(<span style=color:#ae81ff>5</span>);
</span></span><span style=display:flex><span><span style=color:#75715e>--  ?column? 
</span></span></span><span style=display:flex><span><span style=color:#75715e>-- ----------
</span></span></span><span style=display:flex><span><span style=color:#75715e>--  t
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> <span style=color:#e6db74>&#39;foo &#39;</span>::VARCHAR(<span style=color:#ae81ff>5</span>)<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;foo&#39;</span>::VARCHAR(<span style=color:#ae81ff>5</span>);
</span></span><span style=display:flex><span><span style=color:#75715e>--  ?column? 
</span></span></span><span style=display:flex><span><span style=color:#75715e>-- ----------
</span></span></span><span style=display:flex><span><span style=color:#75715e>--  f
</span></span></span></code></pre></div><p>Ceci peut avoir une grande importance, non seulement sur les résultats, mais aussi
sur les plans d&rsquo;exécution :</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> t1 (a VARCHAR(<span style=color:#ae81ff>5</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>INSERT</span> <span style=color:#66d9ef>INTO</span> t1 <span style=color:#66d9ef>SELECT</span> generate_series(<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>10000</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>INDEX</span> idx1 <span style=color:#66d9ef>ON</span> t1(a);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>EXPLAIN</span> <span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>FROM</span> t1 <span style=color:#66d9ef>WHERE</span> a<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;foo&#39;</span>::CHAR(<span style=color:#ae81ff>5</span>);
</span></span><span style=display:flex><span><span style=color:#75715e>--                      QUERY PLAN                     
</span></span></span><span style=display:flex><span><span style=color:#75715e>-- ----------------------------------------------------
</span></span></span><span style=display:flex><span><span style=color:#75715e>--  Seq Scan on t1  (cost=0.00..170.00 rows=1 width=4)
</span></span></span><span style=display:flex><span><span style=color:#75715e>--    Filter: ((a)::bpchar = &#39;foo &#39;::character(5))
</span></span></span></code></pre></div><p>Cette requête ne peut pas utiliser l&rsquo;index sur la colonne <code>a</code> : la colonne est
convertie en <code>CHAR</code> (<code>bpchar</code> en fait, qui est le type interne de PostgreSQL
pour <code>CHAR</code>) pour chaque enregistrement, avant comparaison.</p><p>Ce problème apparaît fréquemment quand la requête est embarquée dans une fonction,
et que les paramètres de cette fonction sont de type <code>CHAR(x)</code>. Par exemple :</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>OR</span> <span style=color:#66d9ef>REPLACE</span> <span style=color:#66d9ef>FUNCTION</span> <span style=color:#66d9ef>public</span>.demo_char(p1 CHARACTER)
</span></span><span style=display:flex><span> <span style=color:#66d9ef>RETURNS</span> CHARACTER VARYING
</span></span><span style=display:flex><span> <span style=color:#66d9ef>LANGUAGE</span> plpgsql
</span></span><span style=display:flex><span><span style=color:#66d9ef>AS</span> <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#66d9ef>function</span><span style=color:#960050;background-color:#1e0010>$</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>DECLARE</span>
</span></span><span style=display:flex><span>  v1 VARCHAR;
</span></span><span style=display:flex><span><span style=color:#66d9ef>BEGIN</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>SELECT</span> <span style=color:#66d9ef>INTO</span> v1 a <span style=color:#66d9ef>FROM</span> t1 <span style=color:#66d9ef>WHERE</span> a<span style=color:#f92672>=</span>p1;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>RETURN</span> v1;
</span></span><span style=display:flex><span><span style=color:#66d9ef>END</span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>$</span><span style=color:#66d9ef>function</span><span style=color:#960050;background-color:#1e0010>$</span>
</span></span></code></pre></div><p>Dans cette fonction, le <code>SELECT</code> réalisera un parcours complet de <code>t1</code>,
systématiquement : il faut convertir la valeur de <code>a</code> vers un <code>CHAR</code> pour comparaison.</p><p>Références :</p><ul><li><a href=https://docs.postgresql.fr/current/datatype-character.html>Types caractères</a></li></ul><h3 id=encodage-des-caractères-et-collationnement>Encodage des caractères et collationnement
<a class=anchor href=#encodage-des-caract%c3%a8res-et-collationnement>#</a></h3><p>L&rsquo;encodage au niveau serveur est défini au niveau d&rsquo;une base de données PostgreSQL.
La variable de session <code>client_encoding</code> permet de définir l&rsquo;encodage au niveau
du client. La valeur par défaut est héritée de l&rsquo;encodage de la base de données
sur laquelle le client est connecté, mais elle peut être redéfinie dynamiquement
en début de session avec l&rsquo;ordre <code>SET</code>, par exemple : <code>SET client_encoding = UTF8</code>.</p><p>Concernant le collationnement, il faut noter un certain nombre d&rsquo;évolutions
depuis la version 8.4 :</p><ul><li>collationnement par instance avant la version 8.4 ;</li><li>collationnement par base de données depuis la version 8.4 ;</li><li>collationnement par colonne/index/ordre SQL depuis la version 9.1.</li></ul><p>Références :</p><ul><li><a href=https://docs.postgresql.fr/current/collation.html>Support des collations</a></li></ul><h3 id=type-de-données-date-et-heure>Type de données date et heure
<a class=anchor href=#type-de-donn%c3%a9es-date-et-heure>#</a></h3><p>Oracle propose plusieurs types de données pour manipuler les dates :</p><ul><li><code>DATE</code>, qui encode la date et l&rsquo;heure jusqu&rsquo;à la seconde ;</li><li><code>TIMESTAMP</code> qui encode la date et l&rsquo;heure, dont la précision peut aller plus
loin que celle du type équivalent de PostgreSQL ;</li><li><code>TIMESTAMP WITH TIME ZONE</code> qui permet également d&rsquo;encoder une information
concernant le fuseau horaire ;</li><li><code>INTERVAL</code> qui offre deux précisions : année/mois ou jour/secondes.</li></ul><p>PostgreSQL, quant à lui, implémente les types de données suivants :</p><ul><li><code>date</code>, qui encode uniquement une date, conformément au standard SQL ;</li><li><code>TIMESTAMP</code> qui encode la date et l&rsquo;heure, avec une résolution de 1 microseconde ;</li><li><code>TIME</code> qui encode uniquement l&rsquo;heure, avec une résolution de 1 microseconde ;</li><li><code>INTERVAL</code> qui offre une précision de 1 microseconde ;</li><li><code>TIME</code> et <code>TIMESTAMP</code> peuvent optionnellement embarquer une timezone (fuseau
horaire), en rajoutant <code>WITH TIME ZONE</code> à la déclaration du type, comme pour Oracle.</li></ul><p>La difficulté du portage d&rsquo;une colonne de type <code>DATE</code> dans une base Oracle réside
dans la difficulté à déterminer si la colonne ne stocke que des dates ou si elle
est utilisée pour stocker des dates avec l&rsquo;heure.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> (<span style=color:#e6db74>&#39;1970-01-01&#39;</span>::DATE 
</span></span><span style=display:flex><span>      <span style=color:#f92672>+</span> <span style=color:#e6db74>&#39;15 YEARS 3 MONTHS 2 DAYS 1 HOUR 23 MINUTES&#39;</span>::INTERVAL) 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>AS</span> calcul_intervalle;
</span></span><span style=display:flex><span><span style=color:#75715e>-- -[ RECORD 1 ]-----+--------------------
</span></span></span><span style=display:flex><span><span style=color:#75715e>-- calcul_intervalle | 1985-04-03 01:23:00
</span></span></span></code></pre></div><p>Références :</p><ul><li><a href=https://docs.postgresql.fr/current/datatype-datetime.html>Types date/heure</a></li></ul><h3 id=traitement-des-types-composites>Traitement des types composites
<a class=anchor href=#traitement-des-types-composites>#</a></h3><p>L&rsquo;ensemble des types pouvant être définis par un utilisateur sont supportés avec
plus ou moins d&rsquo;adaptation. Il peut notamment être nécessaire de redéfinir des
fonctions d&rsquo;entrée / sortie définissant le comportement lors d&rsquo;une insertion / lecture
sur les données du type. Dans la plupart des cas, il s&rsquo;agit de types composites
ou de tableaux parfaitement supportés par PostgreSQL.</p><p>Exemple de type composite version Oracle :</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>OR</span> <span style=color:#66d9ef>REPLACE</span> <span style=color:#66d9ef>TYPE</span> phone_t <span style=color:#66d9ef>AS</span> <span style=color:#66d9ef>OBJECT</span> (
</span></span><span style=display:flex><span>    a_code   CHAR(<span style=color:#ae81ff>3</span>),
</span></span><span style=display:flex><span>    p_number CHAR(<span style=color:#ae81ff>8</span>)
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><p>et version PostgreSQL :</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TYPE</span> phone_t <span style=color:#66d9ef>AS</span> (
</span></span><span style=display:flex><span>    a_code   CHAR(<span style=color:#ae81ff>3</span>),
</span></span><span style=display:flex><span>    p_number CHAR(<span style=color:#ae81ff>8</span>)
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><p>Exemple d&rsquo;un tableau de type :</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>OR</span> <span style=color:#66d9ef>REPLACE</span> <span style=color:#66d9ef>TYPE</span> phonelist <span style=color:#66d9ef>AS</span> VARRAY(<span style=color:#ae81ff>50</span>) <span style=color:#66d9ef>OF</span> phone_t;
</span></span></code></pre></div><p>qui sera traduit en :</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TYPE</span> phonelist <span style=color:#66d9ef>AS</span> (phonelist phone_t[<span style=color:#ae81ff>50</span>]);
</span></span></code></pre></div></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div class=book-languages tabindex=0 aria-haspopup=true><ul><li class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
French</li></ul><ul class=book-languages-list><li><a href=https://example.com/datatypes/ class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
English</a></li></ul></div><div><a class="flex align-center" href=https://github.com/dalibo/from-oracle-to-postgresql/commit/0e0e39630a9315928b94eb8adbab6b0771fc83ec title='Dernière modification par Florent Jardin | November 21, 2022' target=_blank rel=noopener><img src=/svg/calendar.svg class=book-icon alt=Calendar>
<span>November 21, 2022</span></a></div><div><a class="flex align-center" href=https://github.com/dalibo/from-oracle-to-postgresql/edit/main/content.fr/docs/schema/types.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt=Edit>
<span>Modifier cette page</span></a></div></div></footer><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><ul><li><a href=#correspondance-des-types-de-données>Correspondance des types de données</a><ul><li><a href=#traitement-des-booléens>Traitement des booléens</a></li><li><a href=#différences-sur-les-types-caractères>Différences sur les types caractères</a></li><li><a href=#encodage-des-caractères-et-collationnement>Encodage des caractères et collationnement</a></li><li><a href=#type-de-données-date-et-heure>Type de données date et heure</a></li><li><a href=#traitement-des-types-composites>Traitement des types composites</a></li></ul></li></ul></li></ul></nav></div></aside></main></body></html>