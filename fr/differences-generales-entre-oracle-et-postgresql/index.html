<!doctype html><html lang=fr dir=ltr><head><meta name=generator content="Hugo 0.109.0"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Différences générales entre Oracle et PostgreSQL # Cette partie traite des spécificités et des différences générales à prendre en considération dans le cadre de la migration d&rsquo;une base de données Oracle vers PostgreSQL."><meta name=theme-color content="#FFFFFF"><meta property="og:title" content="Différences générales"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://dalibo.github.io/from-oracle-to-postgresql/fr/differences-generales-entre-oracle-et-postgresql/"><meta property="og:site_name" content="Porter Oracle vers PostgreSQL"><title>Différences générales</title><link rel=manifest href=/from-oracle-to-postgresql/manifest.json><link rel=icon href=/from-oracle-to-postgresql/favicon.png type=image/x-icon><link rel=alternate hreflang=en href=https://dalibo.github.io/from-oracle-to-postgresql/general-differences-between-oracle-and-postgresql/ title="General differences"><link rel=stylesheet href=/from-oracle-to-postgresql/book.min.a0b1bf814d7fc28217ec0eea7c47371480fb4f325cec9eb1ae1aa1097d715ec7.css integrity="sha256-oLG/gU1/woIX7A7qfEc3FID7TzJc7J6xrhqhCX1xXsc="><script defer src=/from-oracle-to-postgresql/fr.search.min.e7828a63b0a6f917d99bf7d711c9cbaa10d786e3f83f8aa40da04e3e773dcb9f.js integrity="sha256-54KKY7Cm+RfZm/fXEcnLqhDXhuP4P4qkDaBOPnc9y58="></script>
<script defer src=/from-oracle-to-postgresql/sw.min.83ed3a56e2fac2ed3c3c3e1a69afc266f54bc9e92078450a47292a4db2ee86f1.js integrity="sha256-g+06VuL6wu08PD4aaa/CZvVLyekgeEUKRykqTbLuhvE="></script>
<link rel=alternate type=application/rss+xml href=https://dalibo.github.io/from-oracle-to-postgresql/fr/differences-generales-entre-oracle-et-postgresql/index.xml title="Porter Oracle vers PostgreSQL"></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a href=/from-oracle-to-postgresql/fr><img src=/from-oracle-to-postgresql/images/logo.png alt=Logo><span>Porter Oracle vers PostgreSQL</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Rechercher aria-label=Rechercher maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=https://dalibo.github.io/from-oracle-to-postgresql/fr/differences-generales-entre-oracle-et-postgresql/ class=active>Différences générales</a><ul></ul></li><li><input type=checkbox id=section-88c4d5ca464ed2de3d87c4f315803bbb class=toggle>
<label for=section-88c4d5ca464ed2de3d87c4f315803bbb class="flex justify-between"><a href=https://dalibo.github.io/from-oracle-to-postgresql/fr/portage-du-schema-de-la-base-de-donnees/>Portage du schéma</a></label><ul><li><a href=https://dalibo.github.io/from-oracle-to-postgresql/fr/correspondance-des-types-de-donnees/>Correspondance des types de données</a></li><li><a href=https://dalibo.github.io/from-oracle-to-postgresql/fr/reprise-des-tables/>Reprise des tables</a></li><li><a href=https://dalibo.github.io/from-oracle-to-postgresql/fr/reprise-des-vues/>Reprise des vues</a></li><li><a href=https://dalibo.github.io/from-oracle-to-postgresql/fr/reprise-des-sequences/>Reprise des séquences</a></li><li><a href=https://dalibo.github.io/from-oracle-to-postgresql/fr/reprise-des-index/>Reprise des index</a></li><li><a href=https://dalibo.github.io/from-oracle-to-postgresql/fr/reprise-des-partitions/>Reprise des partitions</a></li></ul></li><li><input type=checkbox id=section-b7e37e1862e6db598e5e41747363d74a class=toggle>
<label for=section-b7e37e1862e6db598e5e41747363d74a class="flex justify-between"><a href=https://dalibo.github.io/from-oracle-to-postgresql/fr/portage-des-requetes-sql/>Portage des requêtes SQL</a></label><ul><li><a href=https://dalibo.github.io/from-oracle-to-postgresql/fr/specificites-des-types-de-donnees/>Spécificités des types de données</a></li><li><a href=https://dalibo.github.io/from-oracle-to-postgresql/fr/jointures/>Jointures</a></li><li><a href=https://dalibo.github.io/from-oracle-to-postgresql/fr/expressions-conditionnelles/>Expressions conditionnelles</a></li><li><a href=https://dalibo.github.io/from-oracle-to-postgresql/fr/traitement-des-hierarchies/>Traitement des hiérarchies</a></li><li><a href=https://dalibo.github.io/from-oracle-to-postgresql/fr/gestion-des-transactions/>Gestion des transactions</a></li></ul></li><li><input type=checkbox id=section-cfaa4d420be7e860c2f111a313f9a252 class=toggle>
<label for=section-cfaa4d420be7e860c2f111a313f9a252 class="flex justify-between"><a href=https://dalibo.github.io/from-oracle-to-postgresql/fr/portage-du-code-pl-sql-vers-pl-pgsql/>Portage du code PL/SQL vers PL/pgSQL</a></label><ul><li><a href=https://dalibo.github.io/from-oracle-to-postgresql/fr/portage-des-procedures-et-fonctions/>Portage des procédures et fonctions</a></li><li><a href=https://dalibo.github.io/from-oracle-to-postgresql/fr/portage-des-triggers/>Portage des triggers</a></li><li><a href=https://dalibo.github.io/from-oracle-to-postgresql/fr/structures-de-controles/>Structures de contrôles</a></li><li><a href=https://dalibo.github.io/from-oracle-to-postgresql/fr/reprise-du-code-pl-sql/>Reprise du code PL/SQL</a></li><li><a href=https://dalibo.github.io/from-oracle-to-postgresql/fr/curseurs/>Curseurs</a></li><li><a href=https://dalibo.github.io/from-oracle-to-postgresql/fr/specificites-pl-sql/>Spécificités PL/SQL</a></li><li><a href=https://dalibo.github.io/from-oracle-to-postgresql/fr/packages-proprietaires/>Packages propriétaires</a></li></ul></li><li><a href=https://dalibo.github.io/from-oracle-to-postgresql/fr/nous-contacter/>Nous contacter</a><ul></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/from-oracle-to-postgresql/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Différences générales</strong>
<label for=toc-control><img src=/from-oracle-to-postgresql/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#différences-générales-entre-oracle-et-postgresql>Différences générales entre Oracle et PostgreSQL</a><ul><li><a href=#utilisateur-et-schéma>Utilisateur et schéma</a></li><li><a href=#sensibilité-à-la-casse>Sensibilité à la casse</a></li><li><a href=#table-dual>Table DUAL</a></li><li><a href=#traitement-de-la-valeur-null>Traitement de la valeur NULL</a></li><li><a href=#database-links>Database Links</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=différences-générales-entre-oracle-et-postgresql>Différences générales entre Oracle et PostgreSQL
<a class=anchor href=#diff%c3%a9rences-g%c3%a9n%c3%a9rales-entre-oracle-et-postgresql>#</a></h1><p>Cette partie traite des spécificités et des différences générales à prendre en
considération dans le cadre de la migration d&rsquo;une base de données Oracle vers
PostgreSQL.</p><h2 id=utilisateur-et-schéma>Utilisateur et schéma
<a class=anchor href=#utilisateur-et-sch%c3%a9ma>#</a></h2><p>Oracle confond la notion d&rsquo;utilisateur et de schéma. La création d&rsquo;un utilisateur
implique la création d&rsquo;un schéma portant le même nom.</p><p>PostgreSQL distingue clairement un utilisateur d&rsquo;un schéma. Le schéma est un réel
espace de nommage pour les objets.</p><h2 id=sensibilité-à-la-casse>Sensibilité à la casse
<a class=anchor href=#sensibilit%c3%a9-%c3%a0-la-casse>#</a></h2><p>Oracle convertit les noms d&rsquo;objets en majuscule, tandis que PostgreSQL les convertit
en minuscule. La norme SQL ne faisant aucune recommandation à ce sujet.</p><p>La casse peut être forcée au besoin en encadrant le nom de l&rsquo;objet manipulé par
deux guillemets doubles (<em>double-quotes</em>).</p><p>Cependant, cette pratique est déconseillée fortement sous PostgreSQL, dans la
mesure où la table <code>"MaTable"</code> ne peut être accessible qu&rsquo;avec les guillemets doubles,
de manière systématique :</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> <span style=color:#e6db74>&#34;MaTable&#34;</span> (a INTEGER <span style=color:#66d9ef>PRIMARY</span> <span style=color:#66d9ef>KEY</span>, b INTEGER);
</span></span><span style=display:flex><span><span style=color:#75715e>-- NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index &#34;MaTable_pkey&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e>--  for table &#34;MaTable&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e>-- CREATE TABLE
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>INSERT</span> <span style=color:#66d9ef>INTO</span> matable (a,b) <span style=color:#66d9ef>VALUES</span> (<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span><span style=color:#75715e>-- ERROR:  relation &#34;matable&#34; does not exist
</span></span></span><span style=display:flex><span><span style=color:#75715e>-- LINE 1: INSERT INTO matable (a,b) values (1,1);
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>     
</span></span><span style=display:flex><span><span style=color:#66d9ef>INSERT</span> <span style=color:#66d9ef>INTO</span> MaTable (a,b) <span style=color:#66d9ef>VALUES</span> (<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span><span style=color:#75715e>-- ERROR:  relation &#34;matable&#34; does not exist
</span></span></span><span style=display:flex><span><span style=color:#75715e>-- LINE 1: INSERT INTO MaTable (a,b) values (1,1);
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>INSERT</span> <span style=color:#66d9ef>INTO</span> <span style=color:#e6db74>&#34;MaTable&#34;</span> (a,b) <span style=color:#66d9ef>VALUES</span> (<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span><span style=color:#75715e>-- INSERT 0 1
</span></span></span></code></pre></div><p>Ainsi, si on oublie les guillemets doubles dans le code, PostgreSQL convertira
systématiquement le nom de table saisi en minuscules.</p><h2 id=table-dual>Table DUAL
<a class=anchor href=#table-dual>#</a></h2><p>L&rsquo;analyseur d&rsquo;Oracle n&rsquo;accepte pas l&rsquo;absence d&rsquo;une clause <code>FROM</code> sur un <code>SELECT</code>.
PostgreSQL n&rsquo;a pas cette limitation, les références à la table <code>DUAL</code> dans une
requête peuvent être supprimées.</p><p>À noter qu&rsquo;il est contre-performant de créer artificiellement une table <code>DUAL</code>
dans PostgreSQL car elle nécessitera l&rsquo;acquisition inutile d&rsquo;un verrou et peut
être source de contentions pour les requêtes utilisant cette table.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> <span style=color:#ae81ff>1</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span> <span style=color:#66d9ef>AS</span> resultat;
</span></span><span style=display:flex><span><span style=color:#75715e>-- -[ RECORD 1 ]
</span></span></span><span style=display:flex><span><span style=color:#75715e>-- resultat | 2
</span></span></span></code></pre></div><h2 id=traitement-de-la-valeur-null>Traitement de la valeur NULL
<a class=anchor href=#traitement-de-la-valeur-null>#</a></h2><p>Le type de données <code>VARCHAR2</code> assimile la chaîne vide à la valeur <code>NULL</code>.
Ce comportement n&rsquo;est pas respectueux de la norme SQL.</p><p>Il peut s&rsquo;ensuivre des problèmes pour la comparaison écrite avec ces spécificités
en tête. De même, Oracle permet de concaténer une chaîne avec une valeur <code>NULL</code>
sans problèmes. Avec PostgreSQL, la valeur <code>NULL</code> est propagée dans les opérations :
une valeur <code>NULL</code> concaténée à une chaîne de caractère donne <code>NULL</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> 
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#39;ABC&#39;</span><span style=color:#f92672>||</span><span style=color:#66d9ef>NULL</span> <span style=color:#66d9ef>AS</span> concatenation_avec_null, 
</span></span><span style=display:flex><span>  coalesce(<span style=color:#e6db74>&#39;ABC&#39;</span><span style=color:#f92672>||</span><span style=color:#66d9ef>NULL</span>,<span style=color:#e6db74>&#39;valeur si null&#39;</span>,<span style=color:#e6db74>&#39;valeur si non null&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#75715e>-- -[ RECORD 1 ]-----------+---------------
</span></span></span><span style=display:flex><span><span style=color:#75715e>-- concatenation_avec_null | 
</span></span></span><span style=display:flex><span><span style=color:#75715e>-- coalesce                | valeur si null
</span></span></span></code></pre></div><h2 id=database-links>Database Links
<a class=anchor href=#database-links>#</a></h2><p>PostgreSQL propose un module externe nommé <code>dblink</code> pour accéder à une base
PostgreSQL distante.</p><p>PostgreSQL implémente également le sous-ensemble SQL/MED de la norme SQL. Ces
fonctionnalités permettent de définir des <em>Foreign Data Wrapper</em> (FDW) qui
permettent d&rsquo;accéder à des objets externes à la base de données : une autre
base de données, un fichier plat, et de nombreuses autres sources de données.</p><p>Parmi ceux-ci, on trouve PostgreSQL, naturellement, mais aussi Oracle. Les
FDW permettent ainsi d&rsquo;intégrer une base PostgreSQL dans un eco-système de
bases Oracle. Concrétement, on définit dans la base PostgreSQL locale des
<code>FOREIGN TABLEs</code> , associées à des tables hébergées sur un serveur distant.
Dès lors, on peut facilement requêter ces tables en SQL, que ce soit pour
de la lecture ou de la mise à jour.</p><p>Un certain nombre de mécanismes, tels que la collecte de statistiques sur
les tables distantes ou la transmission de prédicats de requête sur le serveur
distant, rend ces accès assez efficaces. Néanmoins, il faut garder en tête que
les performances obtenues sont généralement moindres que dans le cas où toutes
les données sont localisées dans la même base.</p><p>Références :</p><ul><li><a href=https://wiki.postgresql.org/wiki/Foreign_data_wrappers>Liste de foreign data wrappers</a></li><li><a href=https://docs.postgresql.fr/current/sql-createforeigntable.html>CREATE FOREIGN TABLE</a> PostgreSQL 14.</li></ul></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div class=book-languages tabindex=0 aria-haspopup=true><ul><li class="flex align-center"><img src=/from-oracle-to-postgresql/svg/translate.svg class=book-icon alt=Languages>
French</li></ul><ul class=book-languages-list><li><a href=https://dalibo.github.io/from-oracle-to-postgresql/general-differences-between-oracle-and-postgresql/ class="flex align-center"><img src=/from-oracle-to-postgresql/svg/translate.svg class=book-icon alt=Languages>
English</a></li></ul></div><div><a class="flex align-center" href=https://github.com/dalibo/from-oracle-to-postgresql/commit/0e0e39630a9315928b94eb8adbab6b0771fc83ec title='Dernière modification par Florent Jardin | November 21, 2022' target=_blank rel=noopener><img src=/from-oracle-to-postgresql/svg/calendar.svg class=book-icon alt=Calendar>
<span>November 21, 2022</span></a></div><div><a class="flex align-center" href=https://github.com/dalibo/from-oracle-to-postgresql/edit/main/content.fr/docs/general/_index.md target=_blank rel=noopener><img src=/from-oracle-to-postgresql/svg/edit.svg class=book-icon alt=Edit>
<span>Modifier cette page</span></a></div></div></footer><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#différences-générales-entre-oracle-et-postgresql>Différences générales entre Oracle et PostgreSQL</a><ul><li><a href=#utilisateur-et-schéma>Utilisateur et schéma</a></li><li><a href=#sensibilité-à-la-casse>Sensibilité à la casse</a></li><li><a href=#table-dual>Table DUAL</a></li><li><a href=#traitement-de-la-valeur-null>Traitement de la valeur NULL</a></li><li><a href=#database-links>Database Links</a></li></ul></li></ul></nav></div></aside></main></body></html>