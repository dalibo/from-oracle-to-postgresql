<!doctype html><html lang=fr dir=ltr><head><meta name=generator content="Hugo 0.109.0"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Gestion des transactions # La gestion des transactions et des verrous est assez similaire entre Oracle et PostgreSQL. Il faut noter deux différences majeures entre les deux SGBD. Tout d&rsquo;abord, Oracle ouvre implicitement une transaction lorsque l&rsquo;on commence à travailler, tandis que PostgreSQL travaille en autocommit par défaut."><meta name=theme-color content="#FFFFFF"><meta property="og:title" content="Gestion des transactions"><meta property="og:description" content="Gestion des transactions # La gestion des transactions et des verrous est assez similaire entre Oracle et PostgreSQL. Il faut noter deux différences majeures entre les deux SGBD. Tout d&rsquo;abord, Oracle ouvre implicitement une transaction lorsque l&rsquo;on commence à travailler, tandis que PostgreSQL travaille en autocommit par défaut."><meta property="og:type" content="article"><meta property="og:url" content="https://dalibo.github.io/from-oracle-to-postgresql/fr/gestion-des-transactions/"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2022-11-21T17:42:55+01:00"><meta property="og:site_name" content="Porter Oracle vers PostgreSQL"><title>Gestion des transactions</title><link rel=manifest href=/from-oracle-to-postgresql/manifest.json><link rel=icon href=/from-oracle-to-postgresql/favicon.png type=image/x-icon><link rel=alternate hreflang=en href=https://dalibo.github.io/from-oracle-to-postgresql/transaction-management/ title="Transaction management"><link rel=stylesheet href=/from-oracle-to-postgresql/book.min.a0b1bf814d7fc28217ec0eea7c47371480fb4f325cec9eb1ae1aa1097d715ec7.css integrity="sha256-oLG/gU1/woIX7A7qfEc3FID7TzJc7J6xrhqhCX1xXsc="><script defer src=/from-oracle-to-postgresql/fr.search.min.e7828a63b0a6f917d99bf7d711c9cbaa10d786e3f83f8aa40da04e3e773dcb9f.js integrity="sha256-54KKY7Cm+RfZm/fXEcnLqhDXhuP4P4qkDaBOPnc9y58="></script>
<script defer src=/from-oracle-to-postgresql/sw.min.83ed3a56e2fac2ed3c3c3e1a69afc266f54bc9e92078450a47292a4db2ee86f1.js integrity="sha256-g+06VuL6wu08PD4aaa/CZvVLyekgeEUKRykqTbLuhvE="></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a href=/from-oracle-to-postgresql/fr><img src=/from-oracle-to-postgresql/images/logo.png alt=Logo><span>Porter Oracle vers PostgreSQL</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Rechercher aria-label=Rechercher maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=https://dalibo.github.io/from-oracle-to-postgresql/fr/differences-generales-entre-oracle-et-postgresql/>Différences générales</a><ul></ul></li><li><input type=checkbox id=section-88c4d5ca464ed2de3d87c4f315803bbb class=toggle>
<label for=section-88c4d5ca464ed2de3d87c4f315803bbb class="flex justify-between"><a href=https://dalibo.github.io/from-oracle-to-postgresql/fr/portage-du-schema-de-la-base-de-donnees/>Portage du schéma</a></label><ul><li><a href=https://dalibo.github.io/from-oracle-to-postgresql/fr/correspondance-des-types-de-donnees/>Correspondance des types de données</a></li><li><a href=https://dalibo.github.io/from-oracle-to-postgresql/fr/reprise-des-tables/>Reprise des tables</a></li><li><a href=https://dalibo.github.io/from-oracle-to-postgresql/fr/reprise-des-vues/>Reprise des vues</a></li><li><a href=https://dalibo.github.io/from-oracle-to-postgresql/fr/reprise-des-sequences/>Reprise des séquences</a></li><li><a href=https://dalibo.github.io/from-oracle-to-postgresql/fr/reprise-des-index/>Reprise des index</a></li><li><a href=https://dalibo.github.io/from-oracle-to-postgresql/fr/reprise-des-partitions/>Reprise des partitions</a></li></ul></li><li><input type=checkbox id=section-b7e37e1862e6db598e5e41747363d74a class=toggle checked>
<label for=section-b7e37e1862e6db598e5e41747363d74a class="flex justify-between"><a href=https://dalibo.github.io/from-oracle-to-postgresql/fr/portage-des-requetes-sql/>Portage des requêtes SQL</a></label><ul><li><a href=https://dalibo.github.io/from-oracle-to-postgresql/fr/specificites-des-types-de-donnees/>Spécificités des types de données</a></li><li><a href=https://dalibo.github.io/from-oracle-to-postgresql/fr/jointures/>Jointures</a></li><li><a href=https://dalibo.github.io/from-oracle-to-postgresql/fr/expressions-conditionnelles/>Expressions conditionnelles</a></li><li><a href=https://dalibo.github.io/from-oracle-to-postgresql/fr/traitement-des-hierarchies/>Traitement des hiérarchies</a></li><li><a href=https://dalibo.github.io/from-oracle-to-postgresql/fr/gestion-des-transactions/ class=active>Gestion des transactions</a></li></ul></li><li><input type=checkbox id=section-cfaa4d420be7e860c2f111a313f9a252 class=toggle>
<label for=section-cfaa4d420be7e860c2f111a313f9a252 class="flex justify-between"><a href=https://dalibo.github.io/from-oracle-to-postgresql/fr/portage-du-code-pl-sql-vers-pl-pgsql/>Portage du code PL/SQL vers PL/pgSQL</a></label><ul><li><a href=https://dalibo.github.io/from-oracle-to-postgresql/fr/portage-des-procedures-et-fonctions/>Portage des procédures et fonctions</a></li><li><a href=https://dalibo.github.io/from-oracle-to-postgresql/fr/portage-des-triggers/>Portage des triggers</a></li><li><a href=https://dalibo.github.io/from-oracle-to-postgresql/fr/structures-de-controles/>Structures de contrôles</a></li><li><a href=https://dalibo.github.io/from-oracle-to-postgresql/fr/reprise-du-code-pl-sql/>Reprise du code PL/SQL</a></li><li><a href=https://dalibo.github.io/from-oracle-to-postgresql/fr/curseurs/>Curseurs</a></li><li><a href=https://dalibo.github.io/from-oracle-to-postgresql/fr/specificites-pl-sql/>Spécificités PL/SQL</a></li><li><a href=https://dalibo.github.io/from-oracle-to-postgresql/fr/packages-proprietaires/>Packages propriétaires</a></li></ul></li><li><a href=https://dalibo.github.io/from-oracle-to-postgresql/fr/nous-contacter/>Nous contacter</a><ul></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/from-oracle-to-postgresql/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Gestion des transactions</strong>
<label for=toc-control><img src=/from-oracle-to-postgresql/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><ul><li><a href=#gestion-des-transactions>Gestion des transactions</a><ul><li><a href=#niveau-disolation>Niveau d&rsquo;isolation</a></li><li><a href=#vérification-des-contraintes>Vérification des contraintes</a></li><li><a href=#savepoint>SAVEPOINT</a></li><li><a href=#gestion-des-verrous>Gestion des verrous</a></li></ul></li></ul></li></ul></nav></aside></header><article class=markdown><h2 id=gestion-des-transactions>Gestion des transactions
<a class=anchor href=#gestion-des-transactions>#</a></h2><p>La gestion des transactions et des verrous est assez similaire entre Oracle et
PostgreSQL. Il faut noter deux différences majeures entre les deux SGBD. Tout
d&rsquo;abord, Oracle ouvre implicitement une transaction lorsque l&rsquo;on commence à
travailler, tandis que PostgreSQL travaille en <code>autocommit</code> par défaut. Il faut
alors ouvrir explicitement une transaction avec l&rsquo;ordre <code>BEGIN</code>.</p><p>L&rsquo;autre différence majeure concerne l&rsquo;implémentation du moteur MVCC de PostgreSQL
qui permet d&rsquo;avoir un coût nul pour les <code>ROLLBACK</code> dans PostgreSQL. En
contrepartie, les blocs modifiés par une transaction qui effectue un <code>ROLLBACK</code>
seront physiquement présents car le moteur de PostgreSQL aura malgré tout créé
de nouvelles versions de ces lignes, bien qu&rsquo;elles aient été annulées. Cet espace
devra être récupéré ensuite par <code>VACUUM</code>.</p><p>L&rsquo;ordre <code>BEGIN</code> a plusieurs déclinaisons synonymes :</p><ul><li><code>BEGIN</code>,</li><li><code>BEGIN WORK</code>,</li><li><code>BEGIN TRANSACTION</code>,</li><li><code>START TRANSACTION</code>.</li></ul><p>Références :</p><ul><li><a href=https://docs.postgresql.fr/current/sql-begin.html>BEGIN</a></li><li><a href=https://docs.postgresql.fr/current/sql-start-transaction.html>START TRANSACTION</a></li></ul><h3 id=niveau-disolation>Niveau d&rsquo;isolation
<a class=anchor href=#niveau-disolation>#</a></h3><p>Il est possible d&rsquo;indiquer le niveau d&rsquo;isolation d&rsquo;une transaction en l&rsquo;indiquant
dans l&rsquo;ordre d&rsquo;ouverture d&rsquo;une transaction :</p><pre tabindex=0><code>BEGIN [ WORK | TRANSACTION ] [ mode_transaction [, ...] ]
</code></pre><p>où <code>mode_transaction</code> est :</p><pre tabindex=0><code>ISOLATION LEVEL 
  {SERIALIZABLE | REPEATABLE READ | READ COMMITTED | READ UNCOMMITTED }
READ WRITE | READ ONLY
[ NOT ] DEFERRABLE
</code></pre><p><code>READ UNCOMMITTED</code> est un synonyme de <code>READ COMMITTED</code> sous PostgreSQL, tout
comme sous Oracle : les moteurs étant MVCC, le mode <code>READ UNCOMMITTED</code> n&rsquo;a pas
d&rsquo;intérêt (les écrivains ne bloquent pas les lecteurs, les lecteurs ne bloquent
pas les écrivains).</p><p>Par ailleurs, Oracle et PostgreSQL implémentent un niveau d&rsquo;isolation
<code>SERIALIZABLE</code>. PostgreSQL implémente le niveau d&rsquo;isolation <code>SERIALIZABLE</code>
avec des verrous optimistes afin de garantir un meilleur débit transactionnel.
La plupart des SGBD implémentent ce niveau d&rsquo;isolation par le biais de verrous
pessimistes, grevant ainsi les performances.</p><p>Oracle permet de positionner le niveau d&rsquo;isolation des transactions pour une
session donnée, c&rsquo;est-à-dire que toutes les transactions réalisées dans la même
session.</p><p>L&rsquo;ordre SQL suivant permet de positionner le niveau d&rsquo;isolation au niveau de la
session pour Oracle :</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>ALTER</span> <span style=color:#66d9ef>SESSION</span> <span style=color:#66d9ef>SET</span> <span style=color:#66d9ef>ISOLATION</span> <span style=color:#66d9ef>LEVEL</span> ...;
</span></span></code></pre></div><p>La même chose est possible avec PostgreSQL au niveau d&rsquo;un bloc transactionnel :</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>BEGIN</span> <span style=color:#66d9ef>TRANSACTION</span> <span style=color:#66d9ef>ISOLATION</span> <span style=color:#66d9ef>LEVEL</span> ...;
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span><span style=color:#66d9ef>COMMIT</span>;
</span></span></code></pre></div><p>La façon pour PostgreSQL de déterminer les violations de sérialisations est plus
stricte que celle d&rsquo;Oracle, mais les deux modes sont très similaires. Par
exemple, l&rsquo;article
<a href=https://asktom.oracle.com/Misc/oramag/on-transaction-isolation-levels.html>&ldquo;On Transaction Isolation Levels&rdquo;</a> reprend une
succession d&rsquo;instructions entre deux sessions, valides avec Oracle (Tableau 7),
qui provoque une erreur dans PostgreSQL.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>create</span> <span style=color:#66d9ef>table</span> a ( x int );
</span></span><span style=display:flex><span><span style=color:#66d9ef>create</span> <span style=color:#66d9ef>table</span> b ( x int );
</span></span></code></pre></div><table><thead><tr><th>Time</th><th>Session #1</th><th>Session #2</th></tr></thead><tbody><tr><td>t1</td><td><code>ALTER SESSION SET isolation_level=serializable;</code></td><td></td></tr><tr><td>t2</td><td></td><td><code>ALTER SESSION SET isolation_level=serializable;</code></td></tr><tr><td>t3</td><td><code>INSERT INTO a SELECT count(*) FROM b;</code></td><td></td></tr><tr><td>t4</td><td></td><td><code>INSERT INTO b SELECT count(*) FROM a;</code></td></tr><tr><td>t5</td><td><code>COMMIT;</code></td><td></td></tr><tr><td>t6</td><td></td><td><code>COMMIT;</code></td></tr></tbody></table><p>PostgreSQL n&rsquo;autorise pas la session #2 à valider ces modifications à cause
d&rsquo;une violation de son instantané (<em>snapshot</em>). Un message d&rsquo;erreur est ainsi
levé en suggérant de recommencer la transaction pour aboutir correctement.</p><pre tabindex=0><code>ERROR: could not serialize access due to read/write dependencies among transactions
DETAIL: Reason code: Canceled on identification as a pivot, during commit attempt.
HINT: The transaction might succeed if retried.
</code></pre><p>Références :</p><ul><li><a href=https://docs.postgresql.fr/current/transaction-iso.html>Isolation des transactions</a></li><li><a href=https://docs.postgresql.fr/current/sql-set-transaction.html>SET TRANSACTION</a></li></ul><h3 id=vérification-des-contraintes>Vérification des contraintes
<a class=anchor href=#v%c3%a9rification-des-contraintes>#</a></h3><p>Les contraintes d&rsquo;intégrité sont vérifiées à chaque instruction d&rsquo;écriture,
qu&rsquo;elle soit exécutée ou non dans une transaction. Pour exiger un respect de ces
contraintes à l&rsquo;issue de plusieurs transformations dans une transaction, il est
possible de différer ces vérifications au moment du <code>COMMIT</code>.</p><p>Oracle et PostgreSQL proposent la même syntaxe SQL pour définir si une
contrainte est différée de façon systématique :</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>ALTER</span> <span style=color:#66d9ef>TABLE</span> ... <span style=color:#66d9ef>CONSTRAINT</span> ...
</span></span><span style=display:flex><span>  [<span style=color:#66d9ef>NOT</span>] <span style=color:#66d9ef>DEFERRABLE</span> <span style=color:#66d9ef>INITIALLY</span> 
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>IMMEDIATE</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>DEFERRED</span>)
</span></span></code></pre></div><p>Il est également possible de désactiver le contrôle au sein d&rsquo;une transaction en
cours à l&rsquo;aide de l&rsquo;instruction suivante, commune au deux systèmes :</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>SET</span> <span style=color:#66d9ef>CONSTRAINT</span> (cons_name <span style=color:#f92672>|</span> <span style=color:#66d9ef>ALL</span>) <span style=color:#66d9ef>DEFERRED</span>;
</span></span></code></pre></div><p>Enfin, il peut être nécessaire de définir au niveau d&rsquo;une session que toutes les
prochaines transactions soient différées par défaut. Dans ce cas, les commandes
entre Oracle et PostgreSQL présentent des différences.</p><p>Avec Oracle, la syntaxe :</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>ALTER</span> <span style=color:#66d9ef>SESSION</span> <span style=color:#66d9ef>SET</span> <span style=color:#66d9ef>CONSTRAINTS</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>DEFERRED</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>ALTER</span> <span style=color:#66d9ef>SESSION</span> <span style=color:#66d9ef>SET</span> <span style=color:#66d9ef>CONSTRAINTS</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>IMMEDIATE</span>;
</span></span></code></pre></div><p>Devra être remplacée par :</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>SET</span> default_transaction_deferrable <span style=color:#f92672>=</span> <span style=color:#66d9ef>ON</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>SET</span> default_transaction_deferrable <span style=color:#f92672>=</span> <span style=color:#66d9ef>OFF</span>;
</span></span></code></pre></div><ul><li><a href=https://docs.postgresql.fr/current/sql-set-constraints.html>SET CONSTRAINTS</a></li></ul><h3 id=savepoint>SAVEPOINT
<a class=anchor href=#savepoint>#</a></h3><p>Les <code>SAVEPOINT</code> fonctionnent sans régression par rapport au SGBD Oracle. Les
verrous acquis avant la mise en place d&rsquo;un <code>SAVEPOINT</code> ne sont pas relâchés
si un <code>SAVEPOINT</code> est relâché par un <code>RELEASE SAVEPOINT</code> ou un
<code>ROLLBACK TO SAVEPOINT</code></p><p>La documentation de PostgreSQL met néanmoins en garde contre la modification de
lignes après le positionnement d&rsquo;un <code>SAVEPOINT</code> alors que ces lignes ont été
verrouillées par un <code>SELECT ... FOR UPDATE</code> avant le positionnement du
<code>SAVEPOINT</code>. En effet, le verrou acquis par le <code>SELECT ... FOR UPDATE</code> peut
être relâché au moment du <code>ROLLBACK TO SAVEPOINT</code>. La séquence suivante d&rsquo;ordres
SQL est donc à éviter :</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>BEGIN</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>FROM</span> ma_table <span style=color:#66d9ef>WHERE</span> cle <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>FOR</span> <span style=color:#66d9ef>UPDATE</span>;
</span></span><span style=display:flex><span>  SAVEPOINT s;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>UPDATE</span> ma_table <span style=color:#66d9ef>SET</span> ... <span style=color:#66d9ef>WHERE</span> cle <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>ROLLBACK</span> <span style=color:#66d9ef>TO</span> SAVEPOINT s;
</span></span></code></pre></div><p>Références :</p><ul><li><a href=https://docs.postgresql.fr/current/sql-savepoint.html>SAVEPOINT</a></li><li><a href=https://docs.postgresql.fr/current/sql-release-savepoint.html>RELEASE SAVEPOINT</a></li><li><a href=https://docs.postgresql.fr/current/sql-rollback-to.html>ROLLBACK TO SAVEPOINT</a></li></ul><h3 id=gestion-des-verrous>Gestion des verrous
<a class=anchor href=#gestion-des-verrous>#</a></h3><p>Bien que PostgreSQL et Oracle partagent de nombreuses similitudes au niveau du
verrouillage, il faut prendre en compte certaines différences subtiles.</p><p>Références :</p><ul><li><a href=https://docs.postgresql.fr/current/explicit-locking.html>Verrouillage explicite</a></li></ul><h4 id=verrouillage-implicite>Verrouillage implicite
<a class=anchor href=#verrouillage-implicite>#</a></h4><p>Les ordres DML acquièrent des verrous implicites. La différence notable entre
Oracle et PostgreSQL concerne l&rsquo;ordre <code>SELECT</code> : Oracle n&rsquo;acquiert aucun verrou,
tandis que PostgreSQL pose un verrou de type <code>ACCESS SHARE</code>. De ce fait, Oracle
ne protège en aucun cas les lecteurs de modifications telles que la suppression
d&rsquo;une table. Une lecture peut être interrompue suite à un <code>DROP TABLE</code> concurrent.
L&rsquo;acquisition par PostgreSQL d&rsquo;un verrou <code>ACCESS SHARE</code> pour la lecture protège
de ce genre de problèmes.</p><p>Les ordres <code>INSERT</code>, <code>UPDATE</code> et <code>DELETE</code> verrouillent les lignes modifiées.</p><p>Références :</p><ul><li><a href=http://uhesse.com/2009/10/27/dropping-a-table-during-select/>Dropping a table during SELECT</a>, blog de Uwe Hesse</li></ul><h4 id=verrouillage-explicite>Verrouillage explicite
<a class=anchor href=#verrouillage-explicite>#</a></h4><p><strong>SELECT FOR UPDATE</strong></p><p>Les ordres <code>SELECT FOR UPDATE</code> peuvent nécessiter des adaptations. La syntaxe
Oracle est en effet un peu plus riche que celle de PostgreSQL pour ce qui
concerne cet ordre SQL.</p><ul><li><p>Oracle propose une syntaxe <code>WAIT</code> et <code>NOWAIT</code>. PostgreSQL ne propose que la
clause <code>NOWAIT</code>. La clause <code>WAIT</code> est implicite si <code>NOWAIT</code> n&rsquo;est pas
spécifié, il faudra donc la supprimer. La requête <code>SELECT ... FOR UPDATE WAIT;</code> devient <code>SELECT ... FOR UPDATE;</code>.</p><ul><li>En l&rsquo;état, la clause <code>OF</code> Oracle est incompatible avec le clause <code>OF</code> de
PostgreSQL. Cette clause permet d&rsquo;indiquer la table verrouillée pour une mise
à jour ultérieure. Seulement, la clause <code>OF</code> d&rsquo;Oracle désigne une colonne
d&rsquo;une table, tandis que la clause <code>OF</code> de PostgreSQL désigne une table.</li></ul></li></ul><p>Références :</p><ul><li><a href=https://docs.postgresql.fr/current/sql-select.html#SQL-FOR-UPDATE-SHARE>SELECT FOR UPDATE</a></li></ul><p><strong>LOCK TABLE</strong></p><p>La syntaxe de l&rsquo;ordre <code>LOCK TABLE</code> d&rsquo;Oracle est compatible avec celle de PostgreSQL
pour les cas généraux. L&rsquo;ensemble des modes de verrouillage proposés par Oracle
existent tous dans PostgreSQL. On peut noter que PostgreSQL propose plus de type
de verrous.</p><p>Tout comme pour l&rsquo;ordre <code>SELECT FOR UPDATE</code>, Oracle propose une syntaxe <code>WAIT</code>
et <code>NOWAIT</code>. PostgreSQL ne propose aussi que la clause<code>NOWAIT</code>. La clause
<code>WAIT</code> est implicite si <code>NOWAIT</code> n&rsquo;est pas spécifié, il faudra donc la
supprimer. La requête <code>LOCK TABLE ... WAIT;</code> devient <code>LOCK TABLE ...;</code>.</p><p>Les clauses <code>PARTITION</code> et <code>SUBPARTITION</code> ne peuvent cependant pas être
reprises. Dans le cas de la mise en œuvre du partitionnement dans PostgreSQL,
il faut désigner la table correspondant à la partition ciblée par l&rsquo;acquisition
d&rsquo;un verrou.</p><p>Références :</p><ul><li><a href=https://docs.postgresql.fr/current/sql-lock.html>LOCK TABLE</a></li></ul></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div class=book-languages tabindex=0 aria-haspopup=true><ul><li class="flex align-center"><img src=/from-oracle-to-postgresql/svg/translate.svg class=book-icon alt=Languages>
French</li></ul><ul class=book-languages-list><li><a href=https://dalibo.github.io/from-oracle-to-postgresql/transaction-management/ class="flex align-center"><img src=/from-oracle-to-postgresql/svg/translate.svg class=book-icon alt=Languages>
English</a></li></ul></div><div><a class="flex align-center" href=https://github.com/dalibo/from-oracle-to-postgresql/commit/0e0e39630a9315928b94eb8adbab6b0771fc83ec title='Dernière modification par Florent Jardin | November 21, 2022' target=_blank rel=noopener><img src=/from-oracle-to-postgresql/svg/calendar.svg class=book-icon alt=Calendar>
<span>November 21, 2022</span></a></div><div><a class="flex align-center" href=https://github.com/dalibo/from-oracle-to-postgresql/edit/main/content.fr/docs/sql/transactions.md target=_blank rel=noopener><img src=/from-oracle-to-postgresql/svg/edit.svg class=book-icon alt=Edit>
<span>Modifier cette page</span></a></div></div></footer><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><ul><li><a href=#gestion-des-transactions>Gestion des transactions</a><ul><li><a href=#niveau-disolation>Niveau d&rsquo;isolation</a></li><li><a href=#vérification-des-contraintes>Vérification des contraintes</a></li><li><a href=#savepoint>SAVEPOINT</a></li><li><a href=#gestion-des-verrous>Gestion des verrous</a></li></ul></li></ul></li></ul></nav></div></aside></main></body></html>