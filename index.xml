<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Porting applications from Oracle to PostgreSQL on From Oracle to PostgreSQL</title><link>https://example.com/</link><description>Recent content in Porting applications from Oracle to PostgreSQL on From Oracle to PostgreSQL</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://example.com/index.xml" rel="self" type="application/rss+xml"/><item><title>Datatypes</title><link>https://example.com/datatypes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/datatypes/</guid><description>Datatypes # The Oracle RDBMS does not support every SQL standard data type natively. Some are supported but converted into an equivalent internal type. For example, all native integer types, like integer being converted to NUMBER(38).</description></item><item><title>Porting procedures and functions</title><link>https://example.com/porting-procedures-and-functions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/porting-procedures-and-functions/</guid><description>Porting procedures and functions # Functions declaration # Both of Oracle and PostgreSQL allow functions and procedures creation, also called routines in PostgreSQL&amp;rsquo;s documentation. Procedures can be invoked by CALL word, while functions are called by SELECT or PERFORM.</description></item><item><title>Specificities on Data types</title><link>https://example.com/specificities-on-data-types/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/specificities-on-data-types/</guid><description>Specificities on Data types # Varchar handling # For Oracle, an empty string is also a NULL string. It is both. PostgreSQL makes the difference: either the string is unknown (IS NULL), either it is empty.</description></item><item><title>Joins</title><link>https://example.com/joins/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/joins/</guid><description>Joins # Oracle supports the ISO-standard way of writing joins only since the 9i version. Previously, joins were written as stipulated by the first SQL standard, with a proprietary notation for outer joins.</description></item><item><title>Table migration</title><link>https://example.com/table-migration/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/table-migration/</guid><description>Table migration # Table definition are quite identical between both RDBMS, except that PostgreSQL does not have global temporary tables. Each temporary table is private to its own session. Data inserted into a temporary table can be automatically destroyed at the transaction end (using ON COMMIT DELETE ROWS clause) or only at the end of the session (with default implicit clause ON COMMIT PRESERVE ROWS).</description></item><item><title>Triggers conversion</title><link>https://example.com/triggers-conversion/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/triggers-conversion/</guid><description>Triggers conversion # Structure of a trigger # In Oracle, a trigger declaration embeds the triggers code. In PostgreSQL, a trigger and a trigger function are two distinct objects: the trigger calls a trigger function depending on the events it must act upon.</description></item><item><title>Conditional expressions</title><link>https://example.com/conditional-expressions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/conditional-expressions/</guid><description>Conditional expressions # Although Oracle as support for the different conditional expressions as specified by the SQL standard, far too many SQL queries still use Oracle&amp;rsquo;s historical functions.
DECODE # Oracle&amp;rsquo;s DECODE function is a proprietary equivalent of the standard compliant CASE clause.</description></item><item><title>Control structures</title><link>https://example.com/control-structures/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/control-structures/</guid><description>Control structures # Loops and control structures don&amp;rsquo;t require a lot of work, except for the GOTO and FORALL instructions.
FOR REVERSE loop # The FOR ... REVERSE has also the peculiarity of needing to revers the min and max boundaries in FOR .</description></item><item><title>Views migration</title><link>https://example.com/views-migration/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/views-migration/</guid><description>Views migration # Simple views are ported with no difficulty to PostgreSQL.
A view is updatable as long as it only references only one table (or another updatable view) and doesn&amp;rsquo;t contain more complex operators, group by, join types, etc.</description></item><item><title>Hierarchical querying</title><link>https://example.com/hierarchical-querying/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/hierarchical-querying/</guid><description>Hierarchical querying # Oracle provides a CONNECT BY function to explore a hierarchical tree. This proprietary functionality has advanced features such as loop detection and provides pseudo-columns such as depth and path.</description></item><item><title>PL/SQL code conversion</title><link>https://example.com/pl-sql-code-conversion/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/pl-sql-code-conversion/</guid><description>PL/SQL code conversion # Empty strings and NULL values # For Oracle, an empty string is NULL too. PostgreSQL makes a difference: IS NULL and empty are different.
Some queries working with Oracle may not work as expected if directly copied.</description></item><item><title>Sequences migration</title><link>https://example.com/sequences-migration/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/sequences-migration/</guid><description>Sequences migration # There is little work on sequences. Sequences are very similar in PostgreSQL and Oracle. A few points need attention, though.
On a general basis, clauses preceded by NO to use default values need a space between NO and the rest of the clause to be ported to PostgreSQL.</description></item><item><title>Cursors</title><link>https://example.com/cursors/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/cursors/</guid><description>Cursors # The cursors variable&amp;rsquo;s notation is different in Oracle and PostgreSQL.
Cursors declaration # With Oracle, a cursor is declared this way: CURSOR mycursor. This has to be reverted with PostgreSQL: mycursor CURSOR.</description></item><item><title>Index migration</title><link>https://example.com/index-migration/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/index-migration/</guid><description>Index migration # Only the BTree indexes match between both databases. The other index types from Oracle don&amp;rsquo;t exist in PostgreSQL, but postgreSQL also has some indexes types of its own.</description></item><item><title>Transaction management</title><link>https://example.com/transaction-management/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/transaction-management/</guid><description>Transaction management # Transactions and locks are very similar between Oracle and PostgreSQL. There are two major differences. First, Oracle implicitely starts a new transaction when a statement is run and keeps it running until COMMIT, while PostgreSQL is using autocommit by default.</description></item><item><title>Partitioning</title><link>https://example.com/partitioning/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/partitioning/</guid><description>Partitioning # PostgreSQL accepts declarative partitioning since version 10 and things keep getting better from major release to another. A table is devided into partitions as declared by its partitioned key, which is decisive when defining the model and could be costly to change during the life of the data.</description></item><item><title>PL/SQL specificities</title><link>https://example.com/pl-sql-specificities/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/pl-sql-specificities/</guid><description>PL/SQL specificities # Autonomous transactions # We often find PRAGMA associated with autonomous transactions in PL/SQL. This last notion does not exist in PostgreSQL.
It is possible to emulate autonomous transactions through a dblink, but it is a particularly counter-efficient solution that consumes resources.</description></item><item><title>Oracle's packages</title><link>https://example.com/oracles-packages/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.com/oracles-packages/</guid><description>Oracle&amp;rsquo;s packages # Proprietary packages have few or no equivalents in PostgreSQL. It is possible rewrite them entirely or to rely on free contributions to obtain behavior close to those proposed by Oracle.</description></item></channel></rss>