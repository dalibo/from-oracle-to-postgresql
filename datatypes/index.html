<!doctype html><html lang=en dir=ltr><head><meta name=generator content="Hugo 0.109.0"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Datatypes # The Oracle RDBMS does not support every SQL standard data type natively. Some are supported but converted into an equivalent internal type. For example, all native integer types, like integer being converted to NUMBER(38)."><meta name=theme-color content="#FFFFFF"><meta property="og:title" content="Datatypes"><meta property="og:description" content="Datatypes # The Oracle RDBMS does not support every SQL standard data type natively. Some are supported but converted into an equivalent internal type. For example, all native integer types, like integer being converted to NUMBER(38)."><meta property="og:type" content="article"><meta property="og:url" content="https://dalibo.github.io/from-oracle-to-postgresql/datatypes/"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2023-01-02T14:11:26+01:00"><meta property="og:site_name" content="From Oracle to PostgreSQL"><title>Datatypes</title><link rel=manifest href=/from-oracle-to-postgresql/manifest.json><link rel=icon href=/from-oracle-to-postgresql/favicon.png type=image/x-icon><link rel=alternate hreflang=fr href=https://dalibo.github.io/from-oracle-to-postgresql/fr/correspondance-des-types-de-donnees/ title="Correspondance des types de donnÃ©es"><link rel=stylesheet href=/from-oracle-to-postgresql/book.min.a0b1bf814d7fc28217ec0eea7c47371480fb4f325cec9eb1ae1aa1097d715ec7.css integrity="sha256-oLG/gU1/woIX7A7qfEc3FID7TzJc7J6xrhqhCX1xXsc="><script defer src=/from-oracle-to-postgresql/en.search.min.4a2bcab22125c63bef73ee45ca805f552713e5bdb67d4ae94d978e229298a96d.js integrity="sha256-SivKsiElxjvvc+5FyoBfVScT5b22fUrpTZeOIpKYqW0="></script>
<script defer src=/from-oracle-to-postgresql/sw.min.83ed3a56e2fac2ed3c3c3e1a69afc266f54bc9e92078450a47292a4db2ee86f1.js integrity="sha256-g+06VuL6wu08PD4aaa/CZvVLyekgeEUKRykqTbLuhvE="></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a href=/from-oracle-to-postgresql><img src=/from-oracle-to-postgresql/images/logo.png alt=Logo><span>From Oracle to PostgreSQL</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=https://dalibo.github.io/from-oracle-to-postgresql/general-differences-between-oracle-and-postgresql/>General differences</a><ul></ul></li><li><input type=checkbox id=section-88c4d5ca464ed2de3d87c4f315803bbb class=toggle checked>
<label for=section-88c4d5ca464ed2de3d87c4f315803bbb class="flex justify-between"><a href=https://dalibo.github.io/from-oracle-to-postgresql/porting-the-database-schema-to-postgresql/>Porting database objects</a></label><ul><li><a href=https://dalibo.github.io/from-oracle-to-postgresql/datatypes/ class=active>Datatypes</a></li><li><a href=https://dalibo.github.io/from-oracle-to-postgresql/table-migration/>Table migration</a></li><li><a href=https://dalibo.github.io/from-oracle-to-postgresql/views-migration/>Views migration</a></li><li><a href=https://dalibo.github.io/from-oracle-to-postgresql/sequences-migration/>Sequences migration</a></li><li><a href=https://dalibo.github.io/from-oracle-to-postgresql/index-migration/>Index migration</a></li><li><a href=https://dalibo.github.io/from-oracle-to-postgresql/partitioning/>Partitioning</a></li></ul></li><li><input type=checkbox id=section-b7e37e1862e6db598e5e41747363d74a class=toggle>
<label for=section-b7e37e1862e6db598e5e41747363d74a class="flex justify-between"><a href=https://dalibo.github.io/from-oracle-to-postgresql/porting-sql-queries/>Porting SQL queries</a></label><ul><li><a href=https://dalibo.github.io/from-oracle-to-postgresql/specificities-on-data-types/>Specificities on Data types</a></li><li><a href=https://dalibo.github.io/from-oracle-to-postgresql/joins/>Joins</a></li><li><a href=https://dalibo.github.io/from-oracle-to-postgresql/conditional-expressions/>Conditional expressions</a></li><li><a href=https://dalibo.github.io/from-oracle-to-postgresql/hierarchical-querying/>Hierarchical querying</a></li><li><a href=https://dalibo.github.io/from-oracle-to-postgresql/transaction-management/>Transaction management</a></li></ul></li><li><input type=checkbox id=section-cfaa4d420be7e860c2f111a313f9a252 class=toggle>
<label for=section-cfaa4d420be7e860c2f111a313f9a252 class="flex justify-between"><a href=https://dalibo.github.io/from-oracle-to-postgresql/pl-sql-to-pl-pgsql-porting/>PL/SQL to PL/pgSQL porting</a></label><ul><li><a href=https://dalibo.github.io/from-oracle-to-postgresql/porting-procedures-and-functions/>Porting procedures and functions</a></li><li><a href=https://dalibo.github.io/from-oracle-to-postgresql/triggers-conversion/>Triggers conversion</a></li><li><a href=https://dalibo.github.io/from-oracle-to-postgresql/control-structures/>Control structures</a></li><li><a href=https://dalibo.github.io/from-oracle-to-postgresql/pl-sql-code-conversion/>PL/SQL code conversion</a></li><li><a href=https://dalibo.github.io/from-oracle-to-postgresql/cursors/>Cursors</a></li><li><a href=https://dalibo.github.io/from-oracle-to-postgresql/pl-sql-specificities/>PL/SQL specificities</a></li><li><a href=https://dalibo.github.io/from-oracle-to-postgresql/oracles-packages/>Oracle's packages</a></li></ul></li><li><a href=https://dalibo.github.io/from-oracle-to-postgresql/contact-us/>Contact us</a><ul></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/from-oracle-to-postgresql/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Datatypes</strong>
<label for=toc-control><img src=/from-oracle-to-postgresql/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><ul><li><a href=#datatypes>Datatypes</a><ul><li><a href=#boolean-type>Boolean type</a></li><li><a href=#character-types>Character types</a></li><li><a href=#character-encoding-and-collation>Character encoding and collation</a></li><li><a href=#temporal-types>Temporal types</a></li><li><a href=#composite-types>Composite types</a></li></ul></li></ul></li></ul></nav></aside></header><article class=markdown><h2 id=datatypes>Datatypes
<a class=anchor href=#datatypes>#</a></h2><p>The Oracle RDBMS does not support every SQL standard data type <em>natively</em>. Some are
supported but converted into an equivalent internal type. For example, all native
integer types, like <code>integer</code> being converted to <code>NUMBER(38)</code>. Also, the <code>VARCHAR2</code>
type is specific to Oracle and differs from the standard on its way to handle
the NULL value. Additionally, many Oracle specific data types are named differently
in PostgreSQL.</p><table><thead><tr><th>type Oracle</th><th>type PostgreSQL</th></tr></thead><tbody><tr><td>varchar2, nchar2, nvarchar2, nclob</td><td>varchar, text</td></tr><tr><td>clob, long</td><td>varchar, text</td></tr><tr><td>blob, raw, long raw</td><td>bytea</td></tr><tr><td>number</td><td>numeric, integer, bigint, smallint, real, double precision</td></tr><tr><td>date</td><td>date, timestamp</td></tr><tr><td>binary float</td><td>real</td></tr><tr><td>binary double</td><td>double precision</td></tr></tbody></table><h3 id=boolean-type>Boolean type
<a class=anchor href=#boolean-type>#</a></h3><p>Oracle does not handle a proper boolean type. Depending on the application
developper, a <code>CHAR</code> or a <code>NUMBER</code> type is used to emulate the behavior. Ora2Pg
can handle the transformation of a boolean value to PostgreSQL.</p><p>Also, note that the lack of boolean value in Oracle can result in some pains with
ORM like Hibernate if the datatypes are not ported correctly. The column seen
configured as a boolean on the ORM side will be stored as a <code>NUMBER</code> or <code>CHAR</code> type
on the Oracle side. If no care has been taken to transform the boolean type and
values accordingly, the ORM will look for a boolean value in PostgreSQL and will
find something different, resulting in an error. More generally, when using ORM,
it is better to start from a database schema generated by the application and
convert the data accordingly.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> <span style=color:#66d9ef>true</span> <span style=color:#66d9ef>AND</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span><span style=color:#75715e>-- -[ RECORD 1 ]
</span></span></span><span style=display:flex><span><span style=color:#75715e>-- ?column? | f
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> <span style=color:#66d9ef>true</span> <span style=color:#66d9ef>OR</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span><span style=color:#75715e>-- -[ RECORD 1 ]
</span></span></span><span style=display:flex><span><span style=color:#75715e>-- ?column? | t
</span></span></span></code></pre></div><h3 id=character-types>Character types
<a class=anchor href=#character-types>#</a></h3><p>Oracle implements a specific datatype, <code>VARCHAR2</code>. This type does not handle an
empty string and <code>NULL</code> according the SQL standard, as an empty string and a <code>NULL</code>
are both seen as a <code>NULL</code> value. Thus, in Oracle, when you compare a value with <code>''</code>,
this is equivalent to <code>IS NULL</code>.</p><p>On the contrary, PostgreSQL provides an SQL standard conformant varchar datatype:
comparing to <code>''</code> is something distinct from <code>IS NULL</code>.</p><p>There is another subtle difference regarding length limit, but it usually is not
a problem during porting. While Oracle&rsquo;s length limit is by default expressed in
bytes (it can be changed with NLS_LENGTH_SEMANTICS), PostgreSQL length limit is
expressed in characters. Moreover, in PostgreSQL, one can use a <code>varchar</code> datatype
without providing a limit, which is equivalent to PostgreSQL&rsquo;s <code>text</code> datatype.
In this case, the string will be limited to 1GB.</p><p>While porting applications, another subtle differences can appear while
comparing <code>char</code> and <code>varchar</code> datas. This is not clearly described in the SQL
standard and each RDBMS has its own interpretation: while comparing thoses
types, PostgreSQL converts each data from <code>varchar</code> to <code>char</code>. Some empty spaces
(<em>padding</em>) will be added on the right of <code>varchar</code> string, in order to obtain
the same length as <code>char(x)</code>.</p><p>For example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> <span style=color:#e6db74>&#39;foo&#39;</span>::CHAR(<span style=color:#ae81ff>5</span>)<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;foo &#39;</span>::VARCHAR(<span style=color:#ae81ff>5</span>);
</span></span><span style=display:flex><span><span style=color:#75715e>--  ?column? 
</span></span></span><span style=display:flex><span><span style=color:#75715e>-- ----------
</span></span></span><span style=display:flex><span><span style=color:#75715e>--  t
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> <span style=color:#e6db74>&#39;foo &#39;</span>::CHAR(<span style=color:#ae81ff>5</span>)<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;foo&#39;</span>::VARCHAR(<span style=color:#ae81ff>5</span>);
</span></span><span style=display:flex><span><span style=color:#75715e>--  ?column? 
</span></span></span><span style=display:flex><span><span style=color:#75715e>-- ----------
</span></span></span><span style=display:flex><span><span style=color:#75715e>--  t
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> <span style=color:#e6db74>&#39;foo &#39;</span>::VARCHAR(<span style=color:#ae81ff>5</span>)<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;foo&#39;</span>::VARCHAR(<span style=color:#ae81ff>5</span>);
</span></span><span style=display:flex><span><span style=color:#75715e>--  ?column? 
</span></span></span><span style=display:flex><span><span style=color:#75715e>-- ----------
</span></span></span><span style=display:flex><span><span style=color:#75715e>--  f
</span></span></span></code></pre></div><p>This feature can have undesirable effects on execution plans:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> t1 (a VARCHAR(<span style=color:#ae81ff>5</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>INSERT</span> <span style=color:#66d9ef>INTO</span> t1 <span style=color:#66d9ef>SELECT</span> generate_series(<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>10000</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>INDEX</span> idx1 <span style=color:#66d9ef>ON</span> t1(a);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>EXPLAIN</span> <span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>FROM</span> t1 <span style=color:#66d9ef>WHERE</span> a<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;foo&#39;</span>::CHAR(<span style=color:#ae81ff>5</span>);
</span></span><span style=display:flex><span><span style=color:#75715e>--                      QUERY PLAN                     
</span></span></span><span style=display:flex><span><span style=color:#75715e>-- ----------------------------------------------------
</span></span></span><span style=display:flex><span><span style=color:#75715e>--  Seq Scan on t1  (cost=0.00..170.00 rows=1 width=4)
</span></span></span><span style=display:flex><span><span style=color:#75715e>--    Filter: ((a)::bpchar = &#39;foo &#39;::character(5))
</span></span></span></code></pre></div><p>This query can&rsquo;t take advantage of the index on column <code>a</code>: each value must be
converted to <code>char</code> (in fact to <code>bpchar</code>, which is the internal type for <code>char</code>)
before being compared to the right argument.</p><p>This problem appears frequently when the query is embedded into a function, and
when the function parameters are of type <code>char(x)</code>. For example, the following
function can be problematic:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>OR</span> <span style=color:#66d9ef>REPLACE</span> <span style=color:#66d9ef>FUNCTION</span> <span style=color:#66d9ef>public</span>.demo_char(p1 CHARACTER)
</span></span><span style=display:flex><span> <span style=color:#66d9ef>RETURNS</span> CHARACTER VARYING
</span></span><span style=display:flex><span> <span style=color:#66d9ef>LANGUAGE</span> plpgsql
</span></span><span style=display:flex><span><span style=color:#66d9ef>AS</span> <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#66d9ef>function</span><span style=color:#960050;background-color:#1e0010>$</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>DECLARE</span>
</span></span><span style=display:flex><span>  v1 VARCHAR;
</span></span><span style=display:flex><span><span style=color:#66d9ef>BEGIN</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>SELECT</span> <span style=color:#66d9ef>INTO</span> v1 a <span style=color:#66d9ef>FROM</span> t1 <span style=color:#66d9ef>WHERE</span> a<span style=color:#f92672>=</span>p1;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>RETURN</span> v1;
</span></span><span style=display:flex><span><span style=color:#66d9ef>END</span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>$</span><span style=color:#66d9ef>function</span><span style=color:#960050;background-color:#1e0010>$</span>
</span></span></code></pre></div><p>In this function, the <code>SELECT</code> statement will always do a sequential scan of
table <code>t1</code> because of the implicit casting issue.</p><p>References:</p><ul><li><a href=https://www.postgresql.org/docs/current/datatype-character.html>Character Types</a></li></ul><h3 id=character-encoding-and-collation>Character encoding and collation
<a class=anchor href=#character-encoding-and-collation>#</a></h3><p>In PostgreSQL, Server-side encoding is set at the database-level. A session
variable named <code>client_encoding</code> can define the encoding at the client-level.
Its default value is set accordingly to the database encoding, but can be
redefined dynamically at session start with <code>SET</code>, for example:
<code>SET client_encoding = UTF8</code>.</p><p>Regarding collation handling, some improvements were made since PostgreSQL 8.4:</p><ul><li>collation global to the database cluster before release 8.4;</li><li>collation per database since release 8.4;</li><li>collation per column/index/SQL query since release 9.1.</li></ul><p>References:</p><ul><li><a href=http://www.postgresql.org/docs/current/static/collation.html>Collation Support</a></li></ul><h3 id=temporal-types>Temporal types
<a class=anchor href=#temporal-types>#</a></h3><p>Oracle supports several datatypes to manipulate temporal data:</p><ul><li><code>DATE</code>, encodes both date and time, with a resolution of a second;</li><li><code>TIMESTAMP</code>, encodes date and time but with a better resolution than what
PostgreSQL can handle (nanosecond);</li><li><code>TIMESTAMP WITH TIME ZONE</code>, same as above, with information about the time zone;</li><li><code>INTERVAL</code>, can have 2 resolutions: year/month or days/seconds.</li></ul><p>PostgreSQL, on the other side, implements the following datatypes:</p><ul><li><code>date</code>, encodes a date, conforming to the SQL standard;</li><li><code>timestamp</code>, encodes date and time, with a resolution up to 1 microsecond;</li><li><code>time</code>, encodes time only, with a resolution up to 1 microsecond;</li><li><code>interval</code> which offers a resolution up to 1 microsecond;</li><li><code>time</code> and <code>timestamp</code> can optionally hold time zone information by adding
<code>with time zone</code> keywords, like in Oracle.</li></ul><p>The problem when porting data typed as <code>DATE</code> in Oracle resides in knowning if it
holds only the date part or it also holds the time part.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> (<span style=color:#e6db74>&#39;1970-01-01&#39;</span>::DATE 
</span></span><span style=display:flex><span>      <span style=color:#f92672>+</span> <span style=color:#e6db74>&#39;15 YEARS 3 MONTHS 2 DAYS 1 HOUR 23 MINUTES&#39;</span>::INTERVAL) 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>AS</span> calc_interval;
</span></span><span style=display:flex><span><span style=color:#75715e>-- -[ RECORD 1 ]-+--------------------
</span></span></span><span style=display:flex><span><span style=color:#75715e>-- calc_interval | 1985-04-03 01:23:00
</span></span></span></code></pre></div><p>References:</p><ul><li><a href=http://www.postgresql.org/docs/current/static/datatype-datetime.html>Date/Time Types</a></li></ul><h3 id=composite-types>Composite types
<a class=anchor href=#composite-types>#</a></h3><p>All of the types that can be defined by a user are supported, but may require
some adaptation. One could need to define input/output functions for these types,
to manage selects and inserts on this peculiar data type. In most cases, the
types are composite or array types that are completely supported by PostgreSQL.</p><p>The following composite type for Oracle:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>OR</span> <span style=color:#66d9ef>REPLACE</span> <span style=color:#66d9ef>TYPE</span> phone_t <span style=color:#66d9ef>AS</span> <span style=color:#66d9ef>OBJECT</span> (
</span></span><span style=display:flex><span>    a_code   CHAR(<span style=color:#ae81ff>3</span>),
</span></span><span style=display:flex><span>    p_number CHAR(<span style=color:#ae81ff>8</span>)
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><p>and the same for PostgreSQL:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TYPE</span> phone_t <span style=color:#66d9ef>AS</span> (
</span></span><span style=display:flex><span>    a_code   CHAR(<span style=color:#ae81ff>3</span>),
</span></span><span style=display:flex><span>    p_number CHAR(<span style=color:#ae81ff>8</span>)
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><p>The following example using an array:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>OR</span> <span style=color:#66d9ef>REPLACE</span> <span style=color:#66d9ef>TYPE</span> phonelist <span style=color:#66d9ef>AS</span> VARRAY(<span style=color:#ae81ff>50</span>) <span style=color:#66d9ef>OF</span> phone_t;
</span></span></code></pre></div><p>will be translated to:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TYPE</span> phonelist <span style=color:#66d9ef>AS</span> (phonelist phone_t[<span style=color:#ae81ff>50</span>]);
</span></span></code></pre></div></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div class=book-languages tabindex=0 aria-haspopup=true><ul><li class="flex align-center"><img src=/from-oracle-to-postgresql/svg/translate.svg class=book-icon alt=Languages>
English</li></ul><ul class=book-languages-list><li><a href=https://dalibo.github.io/from-oracle-to-postgresql/fr/correspondance-des-types-de-donnees/ class="flex align-center"><img src=/from-oracle-to-postgresql/svg/translate.svg class=book-icon alt=Languages>
French</a></li></ul></div><div><a class="flex align-center" href=https://github.com/dalibo/from-oracle-to-postgresql/commit/cabb01b3e1b34311e21f62cd69327e9d8ffd5c9d title='Last modified by Florent Jardin | January 2, 2023' target=_blank rel=noopener><img src=/from-oracle-to-postgresql/svg/calendar.svg class=book-icon alt=Calendar>
<span>January 2, 2023</span></a></div><div><a class="flex align-center" href=https://github.com/dalibo/from-oracle-to-postgresql/edit/main/content.en/docs/schema/types.md target=_blank rel=noopener><img src=/from-oracle-to-postgresql/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></div></footer><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><ul><li><a href=#datatypes>Datatypes</a><ul><li><a href=#boolean-type>Boolean type</a></li><li><a href=#character-types>Character types</a></li><li><a href=#character-encoding-and-collation>Character encoding and collation</a></li><li><a href=#temporal-types>Temporal types</a></li><li><a href=#composite-types>Composite types</a></li></ul></li></ul></li></ul></nav></div></aside></main></body></html>