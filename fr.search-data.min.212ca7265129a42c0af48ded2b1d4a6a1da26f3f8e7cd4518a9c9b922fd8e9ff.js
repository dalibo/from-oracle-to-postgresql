"use strict";(function(){const t={cache:!0};t.doc={id:"id",field:["title","content"],store:["title","href","section"]};const e=FlexSearch.create("balance",t);window.bookSearchIndex=e,e.add({id:0,href:"/from-oracle-to-postgresql/fr/correspondance-des-types-de-donnees/",title:"Correspondance des types de données",section:"Portage du schéma",content:` Correspondance des types de données # Le SGBD Oracle ne supporte pas l\u0026rsquo;ensemble des types de données spécifiés par la norme SQL. Il s\u0026rsquo;agit notamment des types numériques natifs tels que SMALLINT, INT et BIGINT. Le type VARCHAR2 est également une spécificité Oracle, notamment dans sa gestion de la valeur NULL. De plus, un certain nombre de types spécifiques à Oracle sont nommés différemment dans PostgreSQL.
Types Oracle Types PostgreSQL varchar2, nchar2, nvarchar2, nclob varchar ou text clob, long varchar ou text blob, raw, long raw bytea number numeric, integer, bigint, smallint, real, double precision date date ou timestamp binary float real binary double double precision Traitement des booléens # Oracle ne possède pas de type de données représentant des booléens. De ce fait, une chaîne de caractères est souvent utilisée. Ora2Pg permet de convertir des données représentant un booléen vers PostgreSQL.
Par ailleurs, l\u0026rsquo;absence de type booléen dans Oracle entraîne des difficultés avec des ORM tel que Hibernate. En effet, la colonne configurée comme un booléen dans l\u0026rsquo;ORM sera représenté physiquement dans la base Oracle comme un type entier ou un type texte. Or, si le portage de la base de données ne tient pas compte de cette problématique, l\u0026rsquo;ORM cherchera un booléen dans la base PostgreSQL mais trouvera le type équivalent à celui de la base Oracle.
SELECT true AND false; -- -[ RECORD 1 ] -- ?column? | f SELECT true OR false; -- -[ RECORD 1 ] -- ?column? | t Différences sur les types caractères # Oracle implémente un type de données spécifique, VARCHAR2. Parmi ses spécificités, il confond la chaîne vide et la valeur NULL, ce qui est contraire à la norme SQL. Ainsi, sous Oracle, une comparaison avec '' correspond à IS NULL.
PostgreSQL, quant à lui, propose un type de données VARCHAR qui est conforme à la norme. La comparaison avec '' est distincte de IS NULL. Ce type VARCHAR est limitée à 1 Go. PostgreSQL propose également un type text qui est équivalent à un VARCHAR sans limite de taille.
Il faut s\u0026rsquo;attendre aussi à des différences de comportement lors de la comparaison entre types CHAR et VARCHAR. C\u0026rsquo;est une zone assez floue de la norme SQL, et chaque moteur a sa propre interprétation.
Lors de la comparaison de ces deux types, PostgreSQL choisit de convertir le VARCHAR en CHAR. Il applique ensuite une comparaison avec du remplissage (padding) à droite par des blancs jusqu\u0026rsquo;à la longueur du CHAR(x).
Par exemple :
SELECT \u0026#39;foo\u0026#39;::CHAR(5)=\u0026#39;foo \u0026#39;::VARCHAR(5); -- ?column? -- ---------- -- t SELECT \u0026#39;foo \u0026#39;::CHAR(5)=\u0026#39;foo\u0026#39;::VARCHAR(5); -- ?column? -- ---------- -- t SELECT \u0026#39;foo \u0026#39;::VARCHAR(5)=\u0026#39;foo\u0026#39;::VARCHAR(5); -- ?column? -- ---------- -- f Ceci peut avoir une grande importance, non seulement sur les résultats, mais aussi sur les plans d\u0026rsquo;exécution :
CREATE TABLE t1 (a VARCHAR(5)); INSERT INTO t1 SELECT generate_series(1,10000); CREATE INDEX idx1 ON t1(a); EXPLAIN SELECT * FROM t1 WHERE a=\u0026#39;foo\u0026#39;::CHAR(5); -- QUERY PLAN -- ---------------------------------------------------- -- Seq Scan on t1 (cost=0.00..170.00 rows=1 width=4) -- Filter: ((a)::bpchar = \u0026#39;foo \u0026#39;::character(5)) Cette requête ne peut pas utiliser l\u0026rsquo;index sur la colonne a : la colonne est convertie en CHAR (bpchar en fait, qui est le type interne de PostgreSQL pour CHAR) pour chaque enregistrement, avant comparaison.
Ce problème apparaît fréquemment quand la requête est embarquée dans une fonction, et que les paramètres de cette fonction sont de type CHAR(x). Par exemple :
CREATE OR REPLACE FUNCTION public.demo_char(p1 CHARACTER) RETURNS CHARACTER VARYING LANGUAGE plpgsql AS $function$ DECLARE v1 VARCHAR; BEGIN SELECT INTO v1 a FROM t1 WHERE a=p1; RETURN v1; END $function$ Dans cette fonction, le SELECT réalisera un parcours complet de t1, systématiquement : il faut convertir la valeur de a vers un CHAR pour comparaison.
Références :
Types caractères Encodage des caractères et collationnement # L\u0026rsquo;encodage au niveau serveur est défini au niveau d\u0026rsquo;une base de données PostgreSQL. La variable de session client_encoding permet de définir l\u0026rsquo;encodage au niveau du client. La valeur par défaut est héritée de l\u0026rsquo;encodage de la base de données sur laquelle le client est connecté, mais elle peut être redéfinie dynamiquement en début de session avec l\u0026rsquo;ordre SET, par exemple : SET client_encoding = UTF8.
Concernant le collationnement, il faut noter un certain nombre d\u0026rsquo;évolutions depuis la version 8.4 :
collationnement par instance avant la version 8.4 ; collationnement par base de données depuis la version 8.4 ; collationnement par colonne/index/ordre SQL depuis la version 9.1. Références :
Support des collations Type de données date et heure # Oracle propose plusieurs types de données pour manipuler les dates :
DATE, qui encode la date et l\u0026rsquo;heure jusqu\u0026rsquo;à la seconde ; TIMESTAMP qui encode la date et l\u0026rsquo;heure, dont la précision peut aller plus loin que celle du type équivalent de PostgreSQL ; TIMESTAMP WITH TIME ZONE qui permet également d\u0026rsquo;encoder une information concernant le fuseau horaire ; INTERVAL qui offre deux précisions : année/mois ou jour/secondes. PostgreSQL, quant à lui, implémente les types de données suivants :
date, qui encode uniquement une date, conformément au standard SQL ; TIMESTAMP qui encode la date et l\u0026rsquo;heure, avec une résolution de 1 microseconde ; TIME qui encode uniquement l\u0026rsquo;heure, avec une résolution de 1 microseconde ; INTERVAL qui offre une précision de 1 microseconde ; TIME et TIMESTAMP peuvent optionnellement embarquer une timezone (fuseau horaire), en rajoutant WITH TIME ZONE à la déclaration du type, comme pour Oracle. La difficulté du portage d\u0026rsquo;une colonne de type DATE dans une base Oracle réside dans la difficulté à déterminer si la colonne ne stocke que des dates ou si elle est utilisée pour stocker des dates avec l\u0026rsquo;heure.
SELECT (\u0026#39;1970-01-01\u0026#39;::DATE + \u0026#39;15 YEARS 3 MONTHS 2 DAYS 1 HOUR 23 MINUTES\u0026#39;::INTERVAL) AS calcul_intervalle; -- -[ RECORD 1 ]-----+-------------------- -- calcul_intervalle | 1985-04-03 01:23:00 Références :
Types date/heure Traitement des types composites # L\u0026rsquo;ensemble des types pouvant être définis par un utilisateur sont supportés avec plus ou moins d\u0026rsquo;adaptation. Il peut notamment être nécessaire de redéfinir des fonctions d\u0026rsquo;entrée / sortie définissant le comportement lors d\u0026rsquo;une insertion / lecture sur les données du type. Dans la plupart des cas, il s\u0026rsquo;agit de types composites ou de tableaux parfaitement supportés par PostgreSQL.
Exemple de type composite version Oracle :
CREATE OR REPLACE TYPE phone_t AS OBJECT ( a_code CHAR(3), p_number CHAR(8) ); et version PostgreSQL :
CREATE TYPE phone_t AS ( a_code CHAR(3), p_number CHAR(8) ); Exemple d\u0026rsquo;un tableau de type :
CREATE OR REPLACE TYPE phonelist AS VARRAY(50) OF phone_t; qui sera traduit en :
CREATE TYPE phonelist AS (phonelist phone_t[50]); `}),e.add({id:1,href:"/from-oracle-to-postgresql/fr/differences-generales-entre-oracle-et-postgresql/",title:"Différences générales",section:"Docs",content:` Différences générales entre Oracle et PostgreSQL # Cette partie traite des spécificités et des différences générales à prendre en considération dans le cadre de la migration d\u0026rsquo;une base de données Oracle vers PostgreSQL.
Utilisateur et schéma # Oracle confond la notion d\u0026rsquo;utilisateur et de schéma. La création d\u0026rsquo;un utilisateur implique la création d\u0026rsquo;un schéma portant le même nom.
PostgreSQL distingue clairement un utilisateur d\u0026rsquo;un schéma. Le schéma est un réel espace de nommage pour les objets.
Sensibilité à la casse # Oracle convertit les noms d\u0026rsquo;objets en majuscule, tandis que PostgreSQL les convertit en minuscule. La norme SQL ne faisant aucune recommandation à ce sujet.
La casse peut être forcée au besoin en encadrant le nom de l\u0026rsquo;objet manipulé par deux guillemets doubles (double-quotes).
Cependant, cette pratique est déconseillée fortement sous PostgreSQL, dans la mesure où la table \u0026quot;MaTable\u0026quot; ne peut être accessible qu\u0026rsquo;avec les guillemets doubles, de manière systématique :
CREATE TABLE \u0026#34;MaTable\u0026#34; (a INTEGER PRIMARY KEY, b INTEGER); -- NOTICE: CREATE TABLE / PRIMARY KEY will create implicit index \u0026#34;MaTable_pkey\u0026#34; -- for table \u0026#34;MaTable\u0026#34; -- CREATE TABLE INSERT INTO matable (a,b) VALUES (1,1); -- ERROR: relation \u0026#34;matable\u0026#34; does not exist -- LINE 1: INSERT INTO matable (a,b) values (1,1); INSERT INTO MaTable (a,b) VALUES (1,1); -- ERROR: relation \u0026#34;matable\u0026#34; does not exist -- LINE 1: INSERT INTO MaTable (a,b) values (1,1); INSERT INTO \u0026#34;MaTable\u0026#34; (a,b) VALUES (1,1); -- INSERT 0 1 Ainsi, si on oublie les guillemets doubles dans le code, PostgreSQL convertira systématiquement le nom de table saisi en minuscules.
Table DUAL # L\u0026rsquo;analyseur d\u0026rsquo;Oracle n\u0026rsquo;accepte pas l\u0026rsquo;absence d\u0026rsquo;une clause FROM sur un SELECT. PostgreSQL n\u0026rsquo;a pas cette limitation, les références à la table DUAL dans une requête peuvent être supprimées.
À noter qu\u0026rsquo;il est contre-performant de créer artificiellement une table DUAL dans PostgreSQL car elle nécessitera l\u0026rsquo;acquisition inutile d\u0026rsquo;un verrou et peut être source de contentions pour les requêtes utilisant cette table.
SELECT 1+1 AS resultat; -- -[ RECORD 1 ] -- resultat | 2 Traitement de la valeur NULL # Le type de données VARCHAR2 assimile la chaîne vide à la valeur NULL. Ce comportement n\u0026rsquo;est pas respectueux de la norme SQL.
Il peut s\u0026rsquo;ensuivre des problèmes pour la comparaison écrite avec ces spécificités en tête. De même, Oracle permet de concaténer une chaîne avec une valeur NULL sans problèmes. Avec PostgreSQL, la valeur NULL est propagée dans les opérations : une valeur NULL concaténée à une chaîne de caractère donne NULL.
SELECT \u0026#39;ABC\u0026#39;||NULL AS concatenation_avec_null, coalesce(\u0026#39;ABC\u0026#39;||NULL,\u0026#39;valeur si null\u0026#39;,\u0026#39;valeur si non null\u0026#39;); -- -[ RECORD 1 ]-----------+--------------- -- concatenation_avec_null | -- coalesce | valeur si null Database Links # PostgreSQL propose un module externe nommé dblink pour accéder à une base PostgreSQL distante.
PostgreSQL implémente également le sous-ensemble SQL/MED de la norme SQL. Ces fonctionnalités permettent de définir des Foreign Data Wrapper (FDW) qui permettent d\u0026rsquo;accéder à des objets externes à la base de données : une autre base de données, un fichier plat, et de nombreuses autres sources de données.
Parmi ceux-ci, on trouve PostgreSQL, naturellement, mais aussi Oracle. Les FDW permettent ainsi d\u0026rsquo;intégrer une base PostgreSQL dans un eco-système de bases Oracle. Concrétement, on définit dans la base PostgreSQL locale des FOREIGN TABLEs , associées à des tables hébergées sur un serveur distant. Dès lors, on peut facilement requêter ces tables en SQL, que ce soit pour de la lecture ou de la mise à jour.
Un certain nombre de mécanismes, tels que la collecte de statistiques sur les tables distantes ou la transmission de prédicats de requête sur le serveur distant, rend ces accès assez efficaces. Néanmoins, il faut garder en tête que les performances obtenues sont généralement moindres que dans le cas où toutes les données sont localisées dans la même base.
Références :
Liste de foreign data wrappers CREATE FOREIGN TABLE PostgreSQL 14. `}),e.add({id:2,href:"/from-oracle-to-postgresql/fr/portage-des-procedures-et-fonctions/",title:"Portage des procédures et fonctions",section:"Portage du code PL/SQL vers PL/pgSQL",content:` Portage des procédures et fonctions # Déclaration des procédures et fonctions # Les deux SGBD permettent de créer des procédures et des fonctions. Les procédures sont appelables par les mêmes requêtes CALL et les fonctions par les SELECT.
Mais les procédures PostgreSQL ne peuvent pas retourner de valeur. Dans le cadre d\u0026rsquo;une migration, les procédures contenant des paramètres OUT doivent donc être transposées en fonctions PostgreSQL.
Il est également possible de transformer une procédure ne retournant rien en une fonction avec un type de retour VOID.
Parmi les principales différences, il faut noter :
la clause RETURN est transposée en RETURNS ; le mot clé IS est transposé en AS ; le corps de la fonction/procédure est encadré des symboles $$ (ou autre) ; la répétition du nom de la fonction/procédure après la clause END finale est inutile ; les variables locales sont définies dans PostgreSQL dans un bloc DECLARE ; le langage est précisé dans PostgreSQL : LANGUAGE plpgsql. Ci-après, la déclaration de la procédure cs_create_job dans une base Oracle :
CREATE OR REPLACE PROCEDURE cs_create_job(v_job_id IN INTEGER) IS a_running_job_count INTEGER; BEGIN ... END; sera portée de la façon suivante pour PostgreSQL :
CREATE OR REPLACE PROCEDURE cs_create_job(v_job_id INTEGER) AS $$ DECLARE a_running_job_count INTEGER; BEGIN ... END; $$ LANGUAGE plpgsql; Références :
Structure de PL/pgSQL Déclarations Attribut DETERMINISTIC # Les fonctions Oracle déclarées avec l\u0026rsquo;attribut DETERMINISTIC seront portées en fonctions PostgreSQL avec un attribut IMMUTABLE. IMMUTABLE et DETERMINISTIC indiquent que la fonction ne peut pas modifier la base de données et qu\u0026rsquo;à arguments constants, la fonction retourne toujours le même résultat. Cette fonctionnalité est supportée par Ora2Pg.
Ainsi, la déclaration suivante pour Oracle :
CREATE OR REPLACE FUNCTION Get_Average_Char(input_ VARCHAR2) RETURN VARCHAR2 DETERMINISTIC IS ... END Get_Average_Char; sera transposée de la façon suivante pour PostgreSQL :
CREATE OR REPLACE FUNCTION get_average_char(input_ VARCHAR) RETURNS VARCHAR AS $$ ... END; $$ LANGUAGE plpgsql IMMUTABLE; Références :
CREATE FUNCTION Attribut PIPELINED et instruction PIPE ROW # Les fonctions Oracle déclarées avec l\u0026rsquo;attribut PIPELINED sont équivalentes aux fonctions SRF ou Set-Returning Functions (fonctions retournant des ensembles) de PostgreSQL. Ainsi, la fonction avec un attribut PIPELINED sera transposé avec une directive SETOF. L\u0026rsquo;instruction PIPE ROW sera transposée par RETURN NEXT.
Le package suivant, extrait d\u0026rsquo;un exemple PL/SQL Oracle implémente l\u0026rsquo;attribut PIPELINED et l\u0026rsquo;instruction PIPE ROW :
CREATE OR REPLACE PACKAGE pkg1 AS TYPE numset_t IS TABLE OF NUMBER; FUNCTION f1(x NUMBER) RETURN numset_t PIPELINED; END pkg1; CREATE PACKAGE BODY pkg1 AS -- FUNCTION f1 RETURNS a collection of elements (1,2,3,... x) FUNCTION f1(x NUMBER) RETURN numset_t PIPELINED IS BEGIN FOR i IN 1..x LOOP PIPE ROW(i); END LOOP; RETURN; END f1; END pkg1; Il est porté assez simplement par Ora2Pg :
le type numset_t n\u0026rsquo;est pas repris, il faudra le modifier manuellement après le portage par Ora2Pg ; si le type de retour était du type %ROWTYPE sous Oracle, il aurait été porté en SET OF record ; le package pkg1 est transformé en schéma pkg1 ; le code de la fonction f1 est transposé comme ci-après. Voici le code PL/pgSQL porté :
CREATE SCHEMA pkg1; CREATE OR REPLACE FUNCTION pkg1.f1 (x INTEGER) RETURNS SET OF INTEGER AS $$ DECLARE i INTEGER; BEGIN FOR i IN 1..x LOOP RETURN NEXT i; END LOOP; RETURN; END; $$ LANGUAGE plpgsql; La fonction sera appelée de la façon suivante : SELECT pkg1.f1(10);.
Références :
Structures de contrôles en PL/pgSQL Paramètres de fonctions # Oracle ne se conforme pas complètement à la norme SQL quant à la déclaration des paramètres d\u0026rsquo;une fonction ou d\u0026rsquo;une procédure. PostgreSQL, quant à lui, se conforme à la norme SQL. Des adaptations mineures sont donc nécessaires pour ce qui concerne le portage de la déclaration des paramètres d\u0026rsquo;une fonction.
Chaque argument est nommé, a un type de données et un mode déterminant le comportement du paramètre. Sous Oracle, le mode du paramètre est déclaré après le nom du paramètre. Sous PostgreSQL, le mode d\u0026rsquo;appel vient avant le nom du paramètre, conformément à la norme SQL. Les modes d\u0026rsquo;appels IN et OUT sont transposés directement, sauf IN OUT qui devient INOUT. Le mode du paramètre peut être ignoré pour les paramètres entrants IN.
Ainsi, les déclarations de paramètres suivants de fonctions Oracle :
CREATE FUNCTION test (p INTEGER) ... CREATE OR REPLACE PROCEDURE cs_parse_url( v_url IN VARCHAR, v_host IN OUT VARCHAR, v_path OUT VARCHAR, v_query OUT VARCHAR ) ... seront transposés de cette manière pour PostgreSQL :
CREATE FUNCTION test (p INTEGER) ... CREATE OR REPLACE FUNCTION cs_parse_url( IN v_url VARCHAR, INOUT v_host VARCHAR, OUT v_path VARCHAR, OUT v_query VARCHAR ) ... Références :
Fonctions avec paramètres en sortie Valeurs par défaut d\u0026rsquo;un argument # PostgreSQL supporte les valeurs par défaut des arguments. Les déclarations de fonctions qui possèdent des valeurs par défaut pour les arguments peuvent être reprises sans adaptation.
Par exemple, une fonction telle que la suivante sous Oracle :
CREATE FUNCTION fonction1 (a INT, b INT, c INT := 0) ... sera réécrite de la façon suivante dans PostgreSQL :
CREATE FUNCTION fonction1 (a INT, b INT, c INT = 0) ... Le mot-clé DEFAULT est valable dans les deux langages.
Références :
CREATE FUNCTION `}),e.add({id:3,href:"/from-oracle-to-postgresql/fr/specificites-des-types-de-donnees/",title:"Spécificités des types de données",section:"Portage des requêtes SQL",content:` Spécificités des types de données # Manipulation des types VARCHAR # Pour Oracle, une chaine vide est aussi une chaîne NULL. Elle a les deux propriétés à la fois. PostgreSQL fait la différence : soit la chaîne est inconnue (IS NULL) soit elle est vide.
Certaines requêtes donnant satisfaction sous Oracle peuvent donner des résultats faux lorsqu\u0026rsquo;elles sont portées directement. Les cas les plus courants sont la comparaison de la valeur d\u0026rsquo;une colonne avec une chaîne vide et la concaténation avec une valeur NULL.
Comparaison # Pour Oracle, si la colonne col est un VARCHAR2, les deux requêtes suivantes vont retourner le même résultat :
SELECT * FROM TABLE WHERE col = \u0026#39;\u0026#39;; SELECT * FROM TABLE WHERE col IS NULL; Mais sous PostgreSQL, les deux requêtes ne retourneront pas le même résultat. Ora2Pg transpose les valeurs NULL des colonnes en VARCHAR2 en valeur NULL pour un type VARCHAR. La première requête ne retournera aucun résultat.
Il est donc nécessaire de réécrire la requête concernée en utilisant les opérateurs IS NULL ou IS NOT NULL. Dans ce cas, la requête pourra utiliser un index pour la recherche.
Si la comparaison est transposée avec une fonction COALESCE et en conservant la comparaison avec la chaîne vide, il ne sera pas possible d\u0026rsquo;utiliser un index pour la recherche.
EXPLAIN SELECT * FROM emp2 WHERE ename IS NULL; -- QUERY PLAN -- ------------------------------------------------------------------------- -- Index Scan using emp2_ename on emp2 (cost=0.00..12.87 rows=1 width=20) -- Index Cond: (ename IS NULL) EXPLAIN SELECT * FROM emp2 WHERE COALESCE(ename) = \u0026#39;\u0026#39;; -- QUERY PLAN -- ------------------------------------------------------------- -- Seq Scan on emp2 (cost=0.00..79144.81 rows=20972 width=20) -- Filter: ((COALESCE(ename))::text = \`::text) Concaténation # Du fait de la spécificité du type VARCHAR2 d\u0026rsquo;Oracle, la concaténation d\u0026rsquo;une valeur NULL dans une chaîne de caractères ne pose pas de problèmes. Elle en pose cependant dans PostgreSQL. Le standard SQL définit en effet que pour la plupart des fonctions, un paramètre NULL entraîne un résultat NULL (on parle de fonctions STRICT dans PostgreSQL). Dans le cas présent, une valeur NULL dans une opération de concaténation sera propagée au résultat : le résultat sera une chaîne NULL et non la chaîne de caractères attendue.
On prendra donc garde à ajouter la fonction COALESCE dans les portions de code touchées par ce problème :
SELECT \u0026#39;nom employé: \u0026#39; || COALESCE(ename, \`) FROM emp; Manipulation de dates # Format de sortie # Pour Oracle, le format défini par NLS_DATE_FORMAT détermine le format des dates qui sera utilisé pour la sortie des fonctions TO_CHAR() et TO_DATE().
Concernant PostgreSQL, par défaut, le format de sortie d\u0026rsquo;une date est conforme au standard SQL: YYYY-MM-DD HH24:MI:SS.mmmmmmm+TZ. Il est cependant possible de le modifier avec la variable de configuration DateStyle (par défaut ISO, DMY).
Opérations sur les dates # Oracle autorise l\u0026rsquo;ajout ou la soustraction d\u0026rsquo;un nombre entier à une date. Par exemple :
SELECT SYSDATE + 1 FROM DUAL; retournera la date de demain. Pour le type date de PostgreSQL, le comportement est identique, mais les deux types date ne le sont pas.
Pour obtenir le même résultat avec un TIMESTAMP (l\u0026rsquo;équivalent du type DATE d\u0026rsquo;Oracle) sous PostgreSQL, il faut utiliser un INTERVAL :
SELECT now() + INTERVAL \u0026#39;1 DAY\u0026#39;; De même, la soustraction d\u0026rsquo;un TIMESTAMP à un autre retourne un nombre correspondant au nombre de jour entre ces deux dates, alors que, sous PostgreSQL, cette opération retourne un intervalle.
Portage de SYSDATE # Attention au type de données DATE sous Oracle, c\u0026rsquo;est en fait du TIMESTAMP WITHOUT TIMEZONE.
SELECT to_char(sysdate,\u0026#39;DD/MM/YYYY HH24:MI:SS\u0026#39;) FROM dual; -- TO_CHAR(SYSDATE,\u0026#39;DD -- ------------------- -- 11/03/2011 14:58:22 Il convient donc d\u0026rsquo;utiliser LOCALTIMESTAMP (et pas current_timestamp qui, lui, contient la timezone…) :
SELECT LOCALTIMESTAMP; -- timestamp -- ---------------------------- -- 2011-03-11 16:59:29.889823 Ainsi, toute variable déclarée en DATE dans du PL/SQL d\u0026rsquo;Oracle doit être déclarée en TIMESTAMP dans du PL/pgsql de PostgreSQL.
`}),e.add({id:4,href:"/from-oracle-to-postgresql/fr/jointures/",title:"Jointures",section:"Portage des requêtes SQL",content:` Jointures # Le SGBD Oracle supporte la syntaxe normalisée d\u0026rsquo;écriture des jointures seulement depuis la version 9i. Auparavant, les jointures étaient exprimées telle que le définissait la première version de la norme SQL, avec une notation propriétaire pour la gestion des jointures externes. PostgreSQL ne supporte pas cette notation propriétaire, mais supporte parfaitement la notation portée par la norme SQL.
Jointure simple # La requête suivante peut être conservée telle qu\u0026rsquo;elle est écrite :
SELECT * FROM t1, t2 WHERE t1.col1 = t2.col1 Cependant, cette syntaxe ne permet pas d\u0026rsquo;écrire de jointure externe. Il est donc recommandé d\u0026rsquo;utiliser systématiquement la nouvelle notation, qui est aussi bien plus lisible dans le cas où des jointures simples et externes sont mélangées :
SELECT * FROM t1 JOIN t2 ON (t1.col1 = t2.col1) Jointure externe à gauche et à droite # Le SGBD Oracle utilise la notation (+) pour décrire le côté où se trouvent les valeurs NULL. Pour une jointure à gauche, l\u0026rsquo;annotation (+) serait placée du côté droit (et inversement pour une jointure à droite). Cette forme n\u0026rsquo;est pas supportée par PostgreSQL. Il faut donc réécrire les jointures avec la notation normalisée : LEFT OUTER JOIN ou LEFT JOIN pour une jointure à gauche et RIGHT OUTER JOIN ou RIGHT JOIN pour une jointure à droite.
La requête suivante, écrite pour Oracle et qui comporte une jointure à gauche :
SELECT * FROM t1, t2 WHERE t1.col1 = t2.col3 (+); nécessite d\u0026rsquo;être réécrite de la manière suivante :
SELECT * FROM t1 LEFT JOIN t2 ON (t1.col1 = t2.col3); De la même façon, la requête suivante comporte une jointure à droite :
SELECT * FROM t1, t2 WHERE t1.col1 (+) = t2.col3; et nécessite d\u0026rsquo;être réécrite de la manière suivante :
SELECT * FROM t1 RIGHT JOIN t2 ON (t1.col1 = t2.col3); Jointure externe complète # Dans les versions précédant la version 9i d\u0026rsquo;Oracle, une jointure externe complète (FULL OUTER JOIN) devait être exprimée à l\u0026rsquo;aide d\u0026rsquo;un UNION entre une jointure à gauche et une jointure à droite. L\u0026rsquo;exemple suivant implémente une jointure externe complète :
SELECT * FROM t1, t2 WHERE t1.col1 = t2.col3 (+) UNION ALL SELECT * FROM t1, t2 WHERE t1.col1 (+) = t2.col3 AND t1.col IS NULL Cette requête doit être réécrite et sera par ailleurs simplifiée de la façon suivante :
SELECT * FROM t1 FULL OUTER JOIN t2 ON (t1.col1 = t2.col3); Mélange de syntaxes de jointure # Lors d\u0026rsquo;un portage d\u0026rsquo;Oracle vers Postgres, il est tentant de ne migrer que les jointures externes, et de garder les autres à l\u0026rsquo;ancienne syntaxe, pour limiter l\u0026rsquo;effort de réécriture.
C\u0026rsquo;est à déconseiller : sur des requêtes complexes, impliquant de nombreuses tables, l\u0026rsquo;optimiseur risque d\u0026rsquo;avoir du mal à calculer un plan d\u0026rsquo;exécution optimal, le contenu de la clause WHERE n\u0026rsquo;étant pas forcément réinjecté en tant que jointure.
Ceci est contrôlé par le paramètre from_collapse_limit de l\u0026rsquo;optimiseur. Il indique la profondeur maximale à laquelle l\u0026rsquo;optimiseur va essayer de réordonner les jointures du WHERE. Il est par défaut à 8, ce qui est la plupart du temps une valeur raisonnable. L\u0026rsquo;augmenter a évidemment un gros impact sur le temps de planification des requêtes.
Voici un exemple très simplifié, dans lequel nous allons forcer from_collapse_limit à 2 pour que le problème se produise sur une requête simple :
CREATE TABLE t1(a INT, b INT); CREATE TABLE t2(b INT, c INT); CREATE TABLE t3(c INT, d INT); CREATE TABLE t4(d INT, e INT); INSERT INTO t1 SELECT generate_series(1,1000000), generate_series(1,1000000); INSERT INTO t2 SELECT generate_series(1,1000000), generate_series(1,1000000); INSERT INTO t3 SELECT generate_series(1,1000000), generate_series(1,1000000); INSERT INTO t4 SELECT generate_series(1,1000000), generate_series(1,1000000); ALTER TABLE t4 add PRIMARY KEY (a); ALTER TABLE t1 add PRIMARY KEY (a); ALTER TABLE t2 add PRIMARY KEY (b); ALTER TABLE t3 add PRIMARY KEY (c); ALTER TABLE t4 add PRIMARY KEY (d); -- Les statistiques sont maintenant à jour analyze; -- 4 tables sont impliquées, mais on n\u0026#39;autorise qu\u0026#39;une profondeur de 2 à l\u0026#39;optimiseur set from_collapse_limit TO 2; -- Jointure « moderne » EXPLAIN ANALYZE SELECT * FROM t1 JOIN t2 USING (b) JOIN t3 USING (c) LEFT JOIN t4 USING (d) WHERE t1.a between 1 AND 100; -- QUERY PLAN -- ------------------------------------------------------------------------- -- Nested Loop Left Join -- (cost=1.70..1271.91 rows=101 width=20) -- (actual time=0.113..4.607 rows=100 loops=1) -- -\u0026gt; Nested Loop -- (cost=1.27..1064.28 rows=101 width=16) -- (actual time=0.097..3.129 rows=100 loops=1) -- -\u0026gt; Nested Loop -- (cost=0.85..856.40 rows=101 width=12) -- (actual time=0.081..1.669 rows=100 loops=1) -- -\u0026gt; Index Scan using t1_pkey on t1 -- (cost=0.42..10.45 rows=101 width=8) -- (actual time=0.057..0.163 rows=100 loops=1) -- Index Cond: ((a \u0026gt;= 1) AND (a \u0026lt;= 100)) -- -\u0026gt; Index Scan using t2_pkey on t2 -- (cost=0.42..8.37 rows=1 width=8) -- (actual time=0.011..0.012 rows=1 loops=100) -- Index Cond: (b = t1.b) -- -\u0026gt; Index Scan using t3_pkey on t3 -- (cost=0.42..2.05 rows=1 width=8) -- (actual time=0.011..0.012 rows=1 loops=100) -- Index Cond: (c = t2.c) -- -\u0026gt; Index Scan using t4_pkey on t4 -- (cost=0.42..2.05 rows=1 width=8) -- (actual time=0.011..0.012 rows=1 loops=100) -- Index Cond: (t3.d = d) -- Total runtime: 4.815 ms -- Mélange de jointures « modernes » pour les jointures externes et de -- jointures SQL89 pour les jointures internes EXPLAIN ANALYZE SELECT * FROM t1,t2,t3 LEFT JOIN t4 USING (d) WHERE t1.b=t2.b AND t2.c=t3.c AND t1.a BETWEEN 1 AND 100; -- QUERY PLAN -- ------------------------------------------------------------------------- -- Hash Join -- (cost=31689.66..79086.67 rows=101 width=28) -- (actual time=711.708..2369.201 rows=100 loops=1) -- Hash Cond: (t3.c = t2.c) -- -\u0026gt; Hash Left Join -- (cost=30832.00..74478.00 rows=1000000 width=12) -- (actual time=711.170..2217.581 rows=1000000 loops=1) -- Hash Cond: (t3.d = t4.d) -- -\u0026gt; Seq Scan on t3 -- (cost=0.00..14425.00 rows=1000000 width=8) -- (actual time=0.007..266.867 rows=1000000 loops=1) -- -\u0026gt; Hash -- (cost=14425.00..14425.00 rows=1000000 width=8) -- (actual time=710.802..710.802 rows=1000000 loops=1) -- Buckets: 131072 Batches: 2 Memory Usage: 19548kB -- -\u0026gt; Seq Scan on t4 -- (cost=0.00..14425.00 rows=1000000 width=8) -- (actual time=0.010..297.606 rows=1000000 loops=1) -- -\u0026gt; Hash -- (cost=856.40..856.40 rows=101 width=16) -- (actual time=0.511..0.511 rows=100 loops=1) -- Buckets: 1024 Batches: 1 Memory Usage: 5kB -- -\u0026gt; Nested Loop -- (cost=0.85..856.40 rows=101 width=16) -- (actual time=0.025..0.459 rows=100 loops=1) -- -\u0026gt; Index Scan using t1_pkey on t1 -- (cost=0.42..10.45 rows=101 width=8) -- (actual time=0.017..0.046 rows=100 loops=1) -- Index Cond: ((a \u0026gt;= 1) AND (a \u0026lt;= 100)) -- -\u0026gt; Index Scan using t2_pkey on t2 -- (cost=0.42..8.37 rows=1 width=8) -- (actual time=0.003..0.003 rows=1 loops=100) -- Index Cond: (b = t1.b) -- Total runtime: 2370.090 ms Avec from_collapse_limit à 8, le problème ne se produit évidemment pas sur cette requête. Toutefois, il est plus sûr de réaliser la correction systématiquement sur toutes les requêtes que de compter le nombre de tables impliquées. Le problème est aussi bien plus dur à diagnostiquer sur une requête complexe faisant usage de sous-requêtes, par exemple.
Produit cartésien # Un produit cartésien peut être exprimé de la façon suivante dans Oracle et PostgreSQL :
SELECT * FROM t1, t2; Néanmoins, la notation normalisée est moins ambigüe et montre clairement l\u0026rsquo;intention de faire un produit cartésien :
SELECT * FROM t1 CROSS JOIN t2; Références :
Expressions de tables `}),e.add({id:5,href:"/from-oracle-to-postgresql/fr/portage-des-triggers/",title:"Portage des triggers",section:"Portage du code PL/SQL vers PL/pgSQL",content:` Portage des triggers # Structure d\u0026rsquo;un trigger # Dans Oracle, la déclaration du trigger embarque également le code du trigger. Dans PostgreSQL, le trigger et le code du trigger sont deux choses distinctes : le trigger appelle une fonction trigger selon les évènements sur lesquels il doit réagir.
Ainsi, pour l\u0026rsquo;exemple du trigger print_salary_changes pour Oracle :
CREATE OR REPLACE TRIGGER print_salary_changes BEFORE DELETE OR INSERT OR UPDATE ON emp FOR EACH ROW WHEN (new.empno \u0026gt; 0) BEGIN ... END; sa déclaration sera scindée en deux au moment du portage :
CREATE OR REPLACE FUNCTION trigger_fct_print_salary_changes() RETURNS TRIGGER AS $$ BEGIN ... END; $$ LANGUAGE plpgsql; CREATE OR REPLACE TRIGGER print_salary_changes BEFORE DELETE OR INSERT OR UPDATE ON emp FOR EACH ROW WHEN (NEW.empno \u0026gt; 0) EXECUTE FUNCTION tgr_print_salary_changes(); On notera que la fonction trigger n\u0026rsquo;a pas de paramètres et retourne un objet de type TRIGGER, spécifique à une fonction trigger. En ce qui concerne les triggers exécutés pour chaque ligne affectée par le DML, l\u0026rsquo;ordre de déclaration du trigger est quant à lui quasi-identique à l\u0026rsquo;ordre Oracle.
Les triggers sur instruction pour Oracle nécessitent une adaptation de l\u0026rsquo;ordre de déclaration du trigger. Dans Oracle, lorsque la mention FOR EACH ROW n\u0026rsquo;est pas précisée, le trigger est un trigger équivalent au type FOR EACH STATEMENT. Dans PostgreSQL, si ce n\u0026rsquo;est pas précisé, le trigger est un trigger FOR EACH ROW - les triggers sur instruction nécessitent donc d\u0026rsquo;être adapté en conséquence. Ora2Pg supporte cette opération.
Ainsi, l\u0026rsquo;équivalent du trigger FOR EACH STATEMENT Oracle s\u0026rsquo;écrit de cette manière :
CREATE OR REPLACE TRIGGER Log_emp_update AFTER UPDATE ON Emp_tab BEGIN INSERT INTO Emp_log (Log_date, Action) VALUES (SYSDATE, \u0026#39;Emp_tab COMMISSIONS CHANGED\u0026#39;); END; Il nécessitera d\u0026rsquo;être réécrit de la façon suivante pour PostgreSQL :
CREATE OR REPLACE FUNCTION trigger_fct_log_emp_update() RETURNS TRIGGER AS $$ BEGIN INSERT INTO emp_log (log_date, action) VALUES (LOCALTIMESTAMP, \u0026#39;Emp_tab COMMISSIONS CHANGED\u0026#39;); END; $$ LANGUAGE plpgsql; CREATE OR REPLACE TRIGGER log_emp_update AFTER UPDATE ON emp_tab FOR EACH STATEMENT EXECUTE FUNCTION trigger_fct_log_emp_update(); PostgreSQL supporte les triggers DML suivants :
BEFORE et AFTER ; FOR EACH ROW et FOR EACH STATEMENT ; sur DELETE, UPDATE, INSERT (COPY est géré par ce même trigger) et TRUNCATE ; la clause UPDATE OF nom_colonne_1 [, nom_colonne_2 ... ] est aussi supportée ; la clause REFERENCING des triggers FOR EACH STATEMENT est aussi supportée pour rendre visible sous forme de table l\u0026rsquo;ensemble des changements apportés par une requête ; conditionnels, avec la clause WHEN (condition). Références :
Fonctions Trigger CREATE TRIGGER Retour d\u0026rsquo;un trigger # PostgreSQL impose de retourner les enregistrements dans les triggers avant action (trigger BEFORE). Dans le cas contraire, la valeur NULL est retournée, bloquant ainsi la mise à jour effective des données. C\u0026rsquo;est un comportement différent de celui d\u0026rsquo;Oracle, pour lequel le retour est implicite.
Ainsi, le trigger Oracle suivant :
CREATE TRIGGER gen_id FOR produit BEFORE INSERT DECLARE noitem INTEGER; As BEGIN SELECT max(no_produit) INTO noitem FROM produit; NEW.no_produit := noitem+1; END; devra être transformé de la façon suivante :
CREATE FUNCTION gen_id () RETURNS TRIGGER AS $$ DECLARE noitem INTEGER; BEGIN SELECT INTO noitem max(no_produit) FROM produit; IF noitem ISNULL THEN noitem:=0; END IF; NEW.no_produit:=noitem+1; RETURN NEW; END; $$ LANGUAGE \u0026#39;plpgsql\u0026#39;; CREATE TRIGGER trig_before_ins_produit BEFORE INSERT ON produit FOR EACH ROW EXECUTE PROCEDURE gen_id(); Références :
Fonctions Trigger Triggers DML # Concernant le portage du code des triggers, ces derniers nécessitent plusieurs adaptations. Tout d\u0026rsquo;abord, les pseudo-tables :new et :old dans un trigger Oracle doivent être transposés entre NEW et OLD dans un trigger PostgreSQL.
Enfin, les codes d\u0026rsquo;opérations INSERTING, UPDATING et DELETING doivent être remplacés par une comparaison sur la variable interne TG_OP : TG_OP = 'INSERT', TG_OP = 'UPDATE' et TG_OP = 'DELETE'.
Le trigger Oracle suivant :
CREATE OR REPLACE TRIGGER testtgop BEFORE INSERT OR DELETE OR UPDATE ON emp FOR EACH ROW BEGIN IF INSERTING THEN ... ELSIF UPDATING THEN ... ELSIF DELETING THEN ... END IF; END; sera donc porté de la façon suivante :
CREATE OR REPLACE FUNCTION trigger_fct_testtgop() RETURNS TRIGGER AS $$ BEGIN IF TG_OP = \u0026#39;INSERT\u0026#39; THEN ... ELSIF TG_OP = \u0026#39;UPDATE\u0026#39; THEN ... ELSIF TG_OP = \u0026#39;DELETE\u0026#39; THEN ... END IF; END; $$ LANGUAGE plpgsql; CREATE OR REPLACE TRIGGER testtgop BEFORE DELETE OR INSERT OR UPDATE ON emp FOR EACH ROW EXECUTE PROCEDURE trigger_fct_testtgop(); Références :
Fonctions Trigger Triggers INSTEAD OF # Ce type de trigger nécessite les mêmes adaptations que les triggers DML.
Triggers DDL et event # Pour reprendre certaines fonctionnalités offertes par les triggers sur DDL et sur événement d\u0026rsquo;Oracle, PostgreSQL dispose d\u0026rsquo;un mécanisme de triggers sur événement, liés aux changements de structure de la base de données (instructions DDL de type CREATE, ALTER, DROP, GRANT, etc).
Ces triggers se déclenchent sur 4 types d\u0026rsquo;événement :
au démarrage d\u0026rsquo;une commande de DDL ; à la terminaison d\u0026rsquo;une commande de DDL ; à la suppression d\u0026rsquo;un objet ; à la réécriture d\u0026rsquo;une table. Pour les suppressions d\u0026rsquo;objet ou les réécritures de table, une interface permet à une fonction PL/pgSQL de, par exemple, tracer ou bloquer l\u0026rsquo;opération.
Néanmoins, pour ce qui est des événements début et fin d\u0026rsquo;une commande, l\u0026rsquo;exploitation des données de contexte fournies par PostgreSQL nécessite du code en C.
Comme pour les triggers DML, l\u0026rsquo;objet EVENT TRIGGER créé doit être associé à une fonction retournant un event_trigger, définie au préalable.
Références :
Event triggers `}),e.add({id:6,href:"/from-oracle-to-postgresql/fr/portage-du-schema-de-la-base-de-donnees/",title:"Portage du schéma",section:"Docs",content:` Portage du schéma de la base de données # Compatibilités des ordres DDL # Dans l\u0026rsquo;ensemble, les ordres DDL sont compatibles entre Oracle et PostgreSQL.
On notera une différence fondamentale entre les deux SGBD :
Oracle effectue un COMMIT implicite après chaque ordre DDL ; au contraire, les ordres DDL sont transactionnels dans PostgreSQL ; les DDL concurrents sont exclusifs à Oracle, mais PostgreSQL propose un CREATE INDEX CONCURRENTLY. BEGIN; CREATE TABLE matable (a INTEGER PRIMARY KEY, b INTEGER); -- NOTICE: CREATE TABLE / PRIMARY KEY will create implicit index \u0026#34;matable_pkey\u0026#34; -- for TABLE \u0026#34;matable\u0026#34; -- CREATE TABLE SELECT count(*) FROM matable; -- -[ RECORD 1 ] -- count | 0 ROLLBACK; SELECT count(*) FROM matable; -- ERROR: relation \u0026#34;matable\u0026#34; does not exist -- LINE 1: SELECT count(*) FROM matable; Reprise des contraintes # La reprise des contraintes d\u0026rsquo;intégrité ne pose pas de difficulté particulière.
Reprise des synonymes # Les synonymes Oracle n\u0026rsquo;ont pas d\u0026rsquo;équivalent direct dans PostgreSQL.
Deux cas de figure sont à traiter pour reprendre les fonctionnalités attachées aux synonymes.
Si le synonyme est en fait un homonyme, permettant par exemple de rendre visible une table d\u0026rsquo;un schéma dans un autre schéma, alors, il suffira de valoriser judicieusement la variable de session PostgreSQL search_path qui indique la liste de schémas dans laquelle PostgreSQL doit chercher les objets dont le schéma n\u0026rsquo;est pas qualifié. Il est possible de spécifier cette variable pour chaque utilisateur de la base de données, ou dynamiquement à n\u0026rsquo;importe quel moment dans une session avec l\u0026rsquo;ordre SET search_path = liste schémas ...;.
Si le synonyme n\u0026rsquo;est pas un homonyme, il est commun de créer une vue pour rendre visible une table dans un autre schéma et sous un autre nom, ou une fonction d\u0026rsquo;encapsulation pour rendre visible une fonction dans un autre schéma sous un autre nom.
Références :
Chemin de parcours des schémas `}),e.add({id:7,href:"/from-oracle-to-postgresql/fr/reprise-des-tables/",title:"Reprise des tables",section:"Portage du schéma",content:` Reprise des tables # La définition des tables est quasiment identique pour les deux SGBD à la différence près que PostgreSQL n\u0026rsquo;a pas de table temporaire globale. Les tables temporaires sont privées à une session. Les données insérées ne persistent que le temps d\u0026rsquo;une transaction (avec la clause ON COMMIT DELETE ROWS ou d\u0026rsquo;une session (avec la clause ON COMMIT PRESERVE ROWS). Sous PostgreSQL c\u0026rsquo;est la table elle même qui est supprimée à la fin de la session ou de la transaction (avec la clause ON COMMIT DROP). Une implémentation équivalente aux tables temporaires globales est proposée plus loin dans ce document.
Il n\u0026rsquo;y a pas non plus de notion de réservation de nombre de transactions allouées à chaque bloc ou d\u0026rsquo;extents. Il n\u0026rsquo;existe donc pas d\u0026rsquo;équivalent à INITTRANS et MAXEXTENTS.
L\u0026rsquo;option PCTFREE qui indique (en pourcentage) l\u0026rsquo;espace que l\u0026rsquo;on souhaite conserver dans le bloc pour les mises à jour correspond au fillfactor sous PostgreSQL. PCTUSED n\u0026rsquo;existe pas (il n\u0026rsquo;a pas de sens dans l\u0026rsquo;implémentation de PostgreSQL).
Références :
CREATE TABLE Colonnes virtuelles # Il existe deux façons de porter les colonnes virtuelles Oracle, définies avec la clause VIRTUAL.
La plus simple consiste à transposer la colonne virtuelle en une colonne calculée. Contrairement à la version Oracle, dans la version PostgreSQL la colonne de la table occupera de la place sur disque. Mais l\u0026rsquo;utilisation de la table est ensuite strictement identique.
Voici un exemple de définition de colonne virtuelle sous Oracle :
CREATE TABLE employees ( id NUMBER, first_name VARCHAR2(10), salary NUMBER(9,2), commission NUMBER(3), salary2 NUMBER GENERATED ALWAYS AS (ROUND(salary*(1+commission/100),2)) VIRTUAL, ); Cette table sera portée dans PostgreSQL de la façon suivante :
CREATE TABLE employees ( id BIGINT, first_name VARCHAR(10), salary DOUBLE PRECISION, commission INTEGER, salary2 DOUBLE PRECISION GENERATED ALWAYS AS (ROUND((salary*(1+commission/100))::numeric,2)) STORED ); Si le stockage de la colonne sur disque est considérée comme gênant, il est aussi possible de créer une vue.
CREATE TABLE employees ( id BIGINT, first_name VARCHAR(10), salary DOUBLE PRECISION, commission INTEGER ); CREATE VIEW virt_employees AS SELECT id, first_name, salary, commission, (ROUND((salary*(1+commission/100))::numeric,2)) salary2 FROM employees; Références :
CREATE TABLE CREATE VIEW Index-Organized Tables # PostgreSQL ne propose pas d\u0026rsquo;équivalent direct des IOT.
Il est néanmoins possible d\u0026rsquo;organiser une table selon un index à l\u0026rsquo;aide de l\u0026rsquo;ordre CLUSTER. Cependant, toutes les écritures ultérieures à la réorganisation ne tiendront pas du tout compte de l\u0026rsquo;ordre de l\u0026rsquo;index. Il est possible de diminuer ce phénomène en appliquant un paramètre fillfactor inférieur à 100 pour laisser de la place aux nouvelles versions des lignes mises à jour car les mises à jour sont conservées sur la même page si l\u0026rsquo;espace libre est suffisant.
Une table organisée selon un index, ou table clusterisée, peut apporter un gain significatif en performance sur les requêtes de type range scan, où des portions consécutives de la table sont ramenées par la requête. Par exemple, une requête qui ramène tous les clients dont le nom commence par MAR (SELECT * FROM clients WHERE nom LIKE 'MAR%';) bénéficiera d\u0026rsquo;une table organisée selon un index. La lecture sera alors plus rapide car les différentes lignes pointées par l\u0026rsquo;index sont normalement dans le même bloc de données.
CLUSTER est donc une opération ponctuelle, à renouveler plus ou moins fréquemment selon le taux d\u0026rsquo;écriture dans la table et des fenêtres de maintenance des applications. Il faut garder à l\u0026rsquo;esprit que cette opération est une opération lourde qui nécessite l\u0026rsquo;acquisition d\u0026rsquo;un verrou d\u0026rsquo;accès exclusif qui bloquera toutes les lectures et écritures durant le temps de la réorganisation. Par ailleurs, aucune réindexation n\u0026rsquo;est nécessaire à la suite d\u0026rsquo;un CLUSTER car les index sont reconstruits à l\u0026rsquo;issue de la réorganisation.
L\u0026rsquo;exemple ci-dessous montre un gain significatif des performances sur une table simple comportant 10 millions de lignes. Le temps d\u0026rsquo;exécution de la requête est divisé par deux après avoir effectué un CLUSTER sur l\u0026rsquo;index approprié.
Création des objets :
CREATE TABLE t6 (i SERIAL PRIMARY KEY, v INTEGER); INSERT INTO t6 (v) SELECT round(random()*10000) FROM generate_series(1, 10000000); CREATE INDEX idx_t6_v ON t6 (v); Le temps d\u0026rsquo;exécution de la requête suivante est constant, les données étant en cache :
SELECT count(*) FROM t6 WHERE v BETWEEN 100 AND 1000; -- count -- -------- -- 902274 -- -- Time: 350,100 ms La table est réorganisée selon l\u0026rsquo;index idx_t6_v :
CLUSTER t6 USING idx_t6_v; Le temps d\u0026rsquo;exécution de la requête précédente est divisé par deux :
SELECT count(*) FROM t6 WHERE v BETWEEN 100 AND 1000; -- count -- -------- -- 902274 -- -- Time: 148,755 ms Références :
CLUSTER Tables externes # Les tables externes permettent de manipuler des fichiers de type CSV depuis une base de données Oracle. Cette fonctionnalité peut être émulée en utilisant un Foreign Data Wrapper. Dans le chapitre précédent relatif aux Database Links, nous avons déjà présenté ces mécanismes d\u0026rsquo;accès à des données distantes. Il s\u0026rsquo;agit ici de les appliquer pour des fichiers plats, par exemple au format CSV.
Soit la définition de la table externe suivante pour Oracle :
CREATE OR REPLACE DIRECTORY ext AS \u0026#39;/usr/tmp/\u0026#39;; CREATE TABLE ext_tab ( empno CHAR(4), ename CHAR(20), job CHAR(20), deptno CHAR(2) ) ORGANIZATION EXTERNAL ( TYPE oracle_loader DEFAULT DIRECTORY ext ACCESS PARAMETERS ( RECORDS DELIMITED BY NEWLINE BADFILE \u0026#39;bad_%a_%p.bad\u0026#39; LOGFILE \u0026#39;log_%a_%p.log\u0026#39; FIELDS TERMINATED BY \u0026#39;,\u0026#39; MISSING FIELD VALUES ARE NULL REJECT ROWS WITH ALL NULL FIELDS (empno, ename, job, deptno)) LOCATION (\u0026#39;demo1.dat\u0026#39;) ) PARALLEL REJECT LIMIT 0 NOMONITORING; Elle sera convertie de la façon suivante dans PostgreSQL :
CREATE EXTENSION file_fdw; CREATE SERVER ext FOREIGN DATA WRAPPER file_fdw; CREATE FOREIGN TABLE ext_tab ( empno CHAR(4), ename CHAR(20), job CHAR(20), deptno CHAR(2) ) SERVER ext OPTIONS(filename \u0026#39;/usr/tmp/demo1.dat\u0026#39;, format \u0026#39;csv\u0026#39;, delimiter \u0026#39;,\u0026#39;); S\u0026rsquo;il s\u0026rsquo;agit seulement de charger des données, il est à noter que l\u0026rsquo;ordre SQL COPY de PostgreSQL est également une solution alternative à la création d\u0026rsquo;un foreign data wrapper. Par exemple, pour charger le fichier CSV de l\u0026rsquo;exemple, il suffit d\u0026rsquo;exécuter l\u0026rsquo;ordre SQL suivant :
COPY ext_table FROM \u0026#39;/usr/tmp/demo1.csv\u0026#39; WITH CSV; Références :
file_fdw COPY Tables temporaires Globales # L\u0026rsquo;objet GLOBAL TEMPORARY TABLE Oracle n\u0026rsquo;a pas d\u0026rsquo;équivalent dans PostgreSQL. Pour rappel, une table temporaire globale est une table dont la structure est permanente, mais dont le contenu est temporaire, c\u0026rsquo;est à dire propre à chaque session utilisateur.
Plusieurs solutions existent pour porter ces objets.
En fonction de l\u0026rsquo;usage qui en est fait, il peut arriver qu\u0026rsquo;une table classique puisse répondre au besoin, avec un simple vidage de la table par une commande TRUNCATE lors de la première utilisation. Mais ceci empêche une utilisation de la table par plusieurs utilisateurs en parallèle.
L\u0026rsquo;extension pgtt, développée par Gilles Darold émule le fonctionnement des tables temporaires globales. Mais son utilisation nécessite que soit chargée la bibliothèque de l\u0026rsquo;extension une fois que l\u0026rsquo;utilisateur est connecté.
Il est également possible de simuler le fonctionnement des tables temporaires globales de la manière suivante :
créer un jeu de tables dans un schéma dédié avec la structure des tables temporaires globales à émuler ; ces tables vont servir de modèle pour la création de tables temporaires ; associer à chaque table un commentaire pour indiquer le mode de fonctionnement de la table temporaire lors des COMMIT de transaction (ON COMMIT PRESERVE ROWS ou ON COMMIT DROP) ; créer une procédure ou fonction d\u0026rsquo;initialisation d\u0026rsquo;une table temporaire sur la base d\u0026rsquo;une table modèle préexistante ; dans le code PL/pgSQL, appeler cette procédure ou fonction à la première utilisation de la table temporaire globale. CREATE SCHEMA IF NOT EXISTS gtt_schema; CREATE TABLE gtt_schema.gtt_table_1 ( col1 INTEGER, col2 TEXT ); COMMENT ON TABLE gtt_schema.gtt_table_1 IS \u0026#39;ON COMMIT PRESERVE ROWS\u0026#39;; CREATE OR REPLACE PROCEDURE prepare_temp_table(p_relname varchar) AS $$ DECLARE v_temp_schema varchar = \u0026#39;gtt_schema\u0026#39;; v_temp_desc varchar; BEGIN -- Lecture du commentaire associé à la table v_temp_desc := pg_catalog.obj_description( (format(\u0026#39;%s.%s\u0026#39;, v_temp_schema, p_relname))::regclass, \u0026#39;pg_class\u0026#39; ); -- Création de la table temporaire EXECUTE format( \u0026#39;CREATE TEMP TABLE %2$s (LIKE %1$s.%2$s) %3$s\u0026#39;, v_temp_schema, p_relname, CASE WHEN v_temp_desc ~* \u0026#39;delete\u0026#39; THEN \u0026#39;ON COMMIT DELETE ROWS\u0026#39; WHEN v_temp_desc ~* \u0026#39;drop\u0026#39; THEN \u0026#39;ON COMMIT DROP\u0026#39; ELSE \u0026#39;ON COMMIT PRESERVE ROWS\u0026#39; END ); -- Si la table temporaire existe déjà, on la vide EXCEPTION WHEN SQLSTATE \u0026#39;42P07\u0026#39; THEN EXECUTE format(\u0026#39;TRUNCATE %s\u0026#39;, p_relname); END; $$ LANGUAGE plpgsql; CALL prepare_temp_table(\u0026#39;gtt_table_1\u0026#39;); Références :
CREATE TABLE. `}),e.add({id:8,href:"/from-oracle-to-postgresql/fr/expressions-conditionnelles/",title:"Expressions conditionnelles",section:"Portage des requêtes SQL",content:` Expressions conditionnelles # Bien qu\u0026rsquo;Oracle implémente les différentes expressions conditionnelles telles qu\u0026rsquo;elles sont spécifiées dans la norme SQL, encore trop de requêtes SQL utilisent les fonctions historiques Oracle.
Portage de DECODE # La fonction DECODE d\u0026rsquo;Oracle est un équivalent propriétaire de la clause CASE, qui est normalisée.
La construction suivante utilise la fonction DECODE :
SELECT emp_name, decode( trunc((yrs_of_service + 3) / 4), 0, 0.04, 1, 0.04, 0.06 ) AS perc_value FROM employees; Cette construction doit être réécrite de cette façon :
SELECT emp_name, CASE WHEN trunc(yrs_of_service + 3) / 4 = 0 THEN 0.04 WHEN trunc(yrs_of_service + 3) / 4 = 1 THEN 0.04 ELSE 0.06 END FROM employees; Cet autre exemple :
DECODE(\u0026#39;user_status\u0026#39;,\u0026#39;active\u0026#39;,\u0026#39;username\u0026#39;,NULL) sera transposé de cette façon :
CASE WHEN user_status=\u0026#39;active\u0026#39; THEN username ELSE NULL END Attention aux commentaires entre le WHEN et le THEN qui ne sont pas supportés par PostgreSQL.
Références :
Expressions conditionnelles Portage de NVL # La fonction NVL d\u0026rsquo;Oracle est encore souvent utilisée, bien que la fonction normalisée COALESCE soit également implémentée. Ces deux fonctions retournent le premier argument qui n\u0026rsquo;est pas NULL. Bien évidemment, PostgreSQL n\u0026rsquo;implémente que la fonction normalisée COALESCE. Un simple remplacement de l\u0026rsquo;appel de NVL par un appel à COALESCE est suffisant.
Ainsi, la requête suivante :
SELECT NVL(description, description_courte, \u0026#39;(aucune)\u0026#39;) FROM articles; se verra portée facilement de cette façon :
SELECT COALESCE(description, description_courte, \u0026#39;(aucune)\u0026#39;) FROM articles; Références :
Expressions conditionnelles Utilisation de ROWNUM # Oracle propose une pseudo-colonne ROWNUM qui permet de numéroter les lignes du résultat d\u0026rsquo;une requête SQL. La clause ROWNUM peut être utilisée soit pour numéroter les lignes de l\u0026rsquo;ensemble retourné par la requête. Elle peut aussi être utilisée pour limiter l\u0026rsquo;ensemble retourné par une requête.
ROWNUM pour numéroter les lignes # Dans le premier cas, à savoir numéroter les lignes de l\u0026rsquo;ensemble retourné par la requête, il faut réécrire la requête pour utiliser la fonction de fenêtrage row_number(). Bien qu\u0026rsquo;Oracle préconise d\u0026rsquo;utiliser la fonction normalisée row_number(), il est fréquent de trouver ROWNUM dans une requête issue d\u0026rsquo;une application s\u0026rsquo;appuyant sur une ancienne version d\u0026rsquo;Oracle :
SELECT ROWNUM, * FROM employees; La requête sera réécrite de la façon suivante :
SELECT row_number() OVER () AS rownum, * FROM employees; Il faut toutefois faire attention à une clause ORDER BY dans une requête employant ROWNUM pour numéroter les lignes retournées par une requête. En effet, le tri commandé par ORDER BY est réalisé après l\u0026rsquo;ajout de la pseudo-colonne ROWNUM. Il faudra vérifier le plan d\u0026rsquo;exécution de la requête sous Oracle et PostgreSQL pour vérifier qu\u0026rsquo;elles retourneront des résultats identiques.
ROWNUM pour limiter le résultat # Pour limiter l\u0026rsquo;ensemble retourné par une requête, il faut supprimer les prédicats utilisant ROWNUM dans la clause et les transformer en couple LIMIT/OFFSET.
La requête suivante retourne les 10 premières lignes de la table employees sous Oracle :
SELECT * FROM employees WHERE ROWNUM \u0026lt; 11; Elle sera réécrite de la façon suivante lors du portage de la requête pour PostgreSQL :
SELECT * FROM employees LIMIT 10; Avec Oracle, si cette même requête est triée à l\u0026rsquo;aide de la clause ORDER BY, la pseudo-colonne ROWNUM est calculée (COUNT STOPKEY) pour chaque ligne afin de garantir le tri qui est réalisé juste après. Le plan d\u0026rsquo;exécution ci-dessous montre l\u0026rsquo;ordre des nœuds qui est retenu pour satisfaire la requête :
--------------------------------------------------------------------------------- | Id | Operation | Name | Rows | Bytes | Cost (%CPU)| Time | --------------------------------------------------------------------------------- | 0 | SELECT STATEMENT | | 10 | 690 | 3 (34)| 00:00:01 | | 1 | SORT ORDER BY | | 10 | 690 | 3 (34)| 00:00:01 | |* 2 | COUNT STOPKEY | | | | | | | 3 | TABLE ACCESS FULL | EMPLOYEES | 10 | 690 | 2 (0)| 00:00:01 | --------------------------------------------------------------------------------- Cette particularité est connue des développeurs et pour palier au comportement de l\u0026rsquo;optimiseur Oracle, il est possible de rencontrer cette forme de requête avec sous-requête, comme suit :
SELECT ROWNUM, r.* FROM (SELECT * FROM t1 ORDER BY col) r WHERE ROWNUM BETWEEN 1 AND 10; Au contraire, PostgreSQL va appliquer le tri avant la limitation du résultat. Lorsque PostgreSQL rencontre une clause LIMIT et un tri avec ORDER BY , il appliquera d\u0026rsquo;abord le tri avant de limiter le résultat. La requête peut alors être simplifiée de cette façon :
SELECT * FROM employees ORDER BY salary DESC LIMIT 10; QUERY PLAN ------------------------------------------------------------------- Limit (cost=81.44..81.46 rows=10 width=8) -\u0026gt; Sort (cost=81.44..87.09 rows=2260 width=8) Sort Key: salary DESC -\u0026gt; Seq Scan on employees (cost=0.00..32.60 rows=2260 width=8) Références :
LIMIT et OFFSET Fonctions Window `}),e.add({id:9,href:"/from-oracle-to-postgresql/fr/portage-des-requetes-sql/",title:"Portage des requêtes SQL",section:"Docs",content:` Compatibilité des ordres DML # La plupart des ordres DML sont compatibles entre Oracle et PostgreSQL. On peut toutefois noter que l\u0026rsquo;ordre MERGE n\u0026rsquo;existe pas encore dans PostgreSQL. Certaines restrictions s\u0026rsquo;appliquent aussi pour l\u0026rsquo;utilisation de certaines fonctions de fenêtrage (window functions) et des CTEs récursives.
Alias de sous-requêtes # Oracle ne génère pas de message d\u0026rsquo;erreur lorsqu\u0026rsquo;une sous-requête ne possède pas d\u0026rsquo;alias. PostgreSQL retourne une erreur dans ses cas là, ce dernier exige que toutes les sous-requêtes disposent d\u0026rsquo;un alias.
Ainsi la requête Oracle suivante :
SELECT colonnes... FROM (SELECT ... ) WHERE predicats Devra être réécrite en choisissant un alias suffisamment descriptif :
SELECT colonnes... FROM (SELECT ... ) sousreq1 WHERE predicats Conversions implicites # Les conversions implicites de et vers un champ de type texte ont été supprimées sous PostgreSQL depuis la version 8.3.
Par exemple, il n\u0026rsquo;est pas possible de faire ce type de requête :
CREATE TABLE depts ( numero CHAR(2), nom VARCHAR(25) ); SELECT * FROM depts WHERE numero BETWEEN 0 AND 42; -- ERROR: operator does not exist: character \u0026gt;= INTEGER -- LIGNE 1 : SELECT * FROM depts WHERE numero BETWEEN 0 AND 42; Si l\u0026rsquo;on veut pouvoir faire faire fonctionner cette requête, il faut préciser explicitement la conversion à réaliser :
SELECT * FROM depts WHERE numero::INTEGER BETWEEN 0 AND 42; -- ou (respect de la norme SQL) SELECT * FROM depts WHERE CAST(id AS INTEGER) BETWEEN 0 AND 42; Avec Oracle, ce type de conversion est implicite.
Clauses HAVING et GROUP BY # Bien que la documentation Oracle indique que la clause GROUP BY précède la clause HAVING, la grammaire Oracle autorise l\u0026rsquo;inverse. Il faut donc corriger les requêtes écrites de la façon HAVING ... GROUP BY.
Les requêtes de la forme suivante :
SELECT * FROM test HAVING count(*) \u0026gt; 3 GROUP BY i; seront transposées de la façon suivante pour pouvoir s\u0026rsquo;exécuter sous PostgreSQL :
SELECT * FROM test GROUP BY i HAVING count(*) \u0026gt; 3; Références :
Clauses GROUP BY et HAVING Utilisation de ROWID # Dans de très rares cas, des requêtes SQL utilisent la colonne ROWID d\u0026rsquo;Oracle, par exemple pour dédoublonner des enregistrements. Le ROWID est la localisation physique d\u0026rsquo;une ligne dans une table. L\u0026rsquo;équivalent dans PostgreSQL est le ctid.
Plus précisément, le ROWID Oracle représente une adresse logique d\u0026rsquo;une ligne, encodée sous la forme OOOOOO.FFF.BBBBBB.RRR où O représente le numéro d\u0026rsquo;objet, F le fichier, B le numéro de bloc et R la ligne dans le bloc. Le format est différent dans le cas d\u0026rsquo;une table stockée dans un BIG FILE TABLESPACE, mais le principe reste identique.
Quant au ctid de PostgreSQL, il ne représente qu\u0026rsquo;un couple (numéro du bloc, numéro de l\u0026rsquo;enregistrement), aucune autre information de localisation physique n\u0026rsquo;est disponible. Le ctid n\u0026rsquo;est donc unique qu\u0026rsquo;au sein d\u0026rsquo;une table. De part ce fait, une requête ramenant le ctid des lignes d\u0026rsquo;une table partitionnée peut présenter des ctid en doublons. On peut dans ce cas utiliser le champ caché tableoid (l\u0026rsquo;identifiant unique de la table dans le catalogue) de chaque table pour différencier les doublons par partition.
Cette méthode d\u0026rsquo;accès est donc à proscrire, sauf opération particulière et cadrée.
Références :
Colonnes système de PostgreSQL Portage de l\u0026rsquo;opérateur ensembliste MINUS # L\u0026rsquo;opérateur ensembliste MINUS est à transposer en EXCEPT pour PostgreSQL. Les autres opérateurs ensemblistes UNION, UNION ALL et INSERSECT ne nécessitent pas de transposition.
Ainsi, la requête suivante retourne les produits de l\u0026rsquo;inventaire qui n\u0026rsquo;ont pas fait l\u0026rsquo;objet d\u0026rsquo;une commande. Elle est exprimée ainsi pour Oracle :
SELECT product_id FROM inventories MINUS SELECT product_id FROM order_items ORDER BY product_id; La requête sera transposé de la façon suivante pour PostgreSQL :
SELECT product_id FROM inventories EXCEPT SELECT product_id FROM order_items ORDER BY product_id; Références :
Opérateurs UNION, INTERSECT et EXCEPT Fonctions de fenêtrage # Les clauses permettant d\u0026rsquo;utiliser les fonctions de fenêtrage ne nécessitent que peu d\u0026rsquo;adaptations.
Oracle propose une clause ORDER SIBLINGS BY. Le mot clé SIBLINGS n\u0026rsquo;a pas d\u0026rsquo;équivalent et est de toute façon dédié à la manipulation des hiérarchies, donc avec CONNECT BY. Une telle requête devra être de toute façon réécrite entièrement pour être portée vers PostgreSQL.
La clause PARTITION BY ne nécessite aucune adaptation, de même que la clause de fenêtrage (RANGE ... ou ROWS ...).
La plupart des fonctions de fenêtrage généralistes d\u0026rsquo;Oracle existent pour PostgreSQL. Certaines fonctions n\u0026rsquo;ont malgré tout pas d\u0026rsquo;équivalent pour l\u0026rsquo;instant :
RATIO_TO_REPORT nécessite simplement d\u0026rsquo;utiliser une division sur le résultat de la fonction SUM ; Le portage de la fonction LISTAGG nécessite une réécriture avec les fonctions array_agg et array_to_string de PostgreSQL. À noter toutefois que les capacités d\u0026rsquo;extensions de PostgreSQL permettent de développer des fonctions d\u0026rsquo;agrégat et des fonctions de fenêtrage, permettant ainsi de palier l\u0026rsquo;absence d\u0026rsquo;équivalent de certaines fonctions.
Références :
Fonctions Window Tutoriel fonctions Window Appels de fonctions Window Fonctions d\u0026rsquo;agrégat CTE récursif # La grammaire Oracle ne distingue pas une CTE simple d\u0026rsquo;une CTE récursive, au contraire de PostgreSQL qui les distingue avec deux syntaxes différentes : WITH et WITH RECURSIVE. Il convient donc de corriger les CTE récursives, notamment en repérant l\u0026rsquo;opérateur UNION ALL et, au sein d\u0026rsquo;une vue, une référence de cette même vue.
La requête suivante pour Oracle réalise une récursion très simple :
WITH recursion (a) AS ( SELECT 1 AS a FROM dual UNION ALL SELECT a + 1 FROM recursion WHERE a \u0026lt; 10 ) SELECT * FROM recursion; Elle sera réécrite de la façon suivante pour PostgreSQL :
WITH RECURSIVE recursion (a) AS ( SELECT 1 AS a UNION ALL SELECT a + 1 FROM recursion WHERE a \u0026lt; 10 ) SELECT * FROM recursion; La clause WITH comprend également des extensions syntaxiques propres à Oracle, pour décrire la façon de réaliser la récursion (search_clause) et la détection des cycles (cycle_clause). Concernant la détection des cycles, un exemple d\u0026rsquo;implémentation est donné dans la partie « Traitement des hiérarchies ».
Références :
SELECT Détection de cycles MERGE # La requête SQL MERGE permet de faire des insertions ou des mises à jour de tables en fonction de l\u0026rsquo;existence préalable ou non des lignes.
La syntaxe typique de l\u0026rsquo;instruction ressemble à ceci :
MERGE INTO table_destination USING table_source ON (condition) WHEN MATCHED THEN update_clause WHEN NOT MATCHED THEN insert_clause; Mais les versions antérieures à PostgreSQL 15 ne supportent pas la syntaxe MERGE de la norme SQL. En revanche, on peut émuler cette instruction avec un INSERT. Il faut ici distinguer plusieurs cas, en fonction de la présence ou non des clauses WHEN MATCHED et WHEN NOT MATCHED.
S\u0026rsquo;il n\u0026rsquo;y a pas de clause WHEN NOT MATCHED, il s\u0026rsquo;agit d\u0026rsquo;un simple UPDATE :
UPDATE table_destination update_clause USING table_source WHERE conditions_de_jointure; S\u0026rsquo;il n\u0026rsquo;y a pas de clause WHEN MATCHED, il s\u0026rsquo;agit d\u0026rsquo;un INSERT sur les lignes qui n\u0026rsquo;existent pas déjà :
INSERT INTO table_destination SELECT ... FROM table_source WHERE conditions_de_jointure ON CONFLICT DO NOTHING; Si les deux clauses WHEN MATCHED et WHEN NOT MATCHED sont présentes, la traduction devient :
INSERT INTO table_destination SELECT ... FROM table_source WHERE conditions_de_jointure ON CONFLICT DO UPDATE update_clause Quelquefois, sur Oracle, un DELETE WHERE ... est présent après l\u0026rsquo;UPDATE de la clause WHEN MATCHED. Dans ce cas, on peut ajouter une simple requête DELETE avant ou après l\u0026rsquo;INSERT. On peut aussi mettre ce DELETE à l\u0026rsquo;intérieur de l\u0026rsquo;INSERT, sous la forme d\u0026rsquo;une expression de table commune (CTE).
Références :
Clause ON CONFLICT Traitement des hints # L\u0026rsquo;optimiseur Oracle supporte des hints, qui permettent au DBA de tromper l\u0026rsquo;optimiseur pour lui faire prendre des chemins que l\u0026rsquo;optimiseur a jugé trop coûteux. Ces hints sont exprimés sous la forme de commentaires et ne seront donc pas pris en compte par PostgreSQL, qui ne gère pas ces hints.
Néanmoins, une requête comportant un hint pour contrôler l\u0026rsquo;optimiseur Oracle doit faire l\u0026rsquo;objet d\u0026rsquo;une attention particulière, et l\u0026rsquo;analyse de son plan d\u0026rsquo;exécution devra être faite minutieusement, pour s\u0026rsquo;assurer que, sous PostgreSQL, la requête n\u0026rsquo;a pas de problème particulier, et agir en conséquence le cas échéant. C\u0026rsquo;est notamment vrai lorsque l\u0026rsquo;une des tables mise en œuvre est particulièrement volumineuse. Mais, de manière générale, l\u0026rsquo;ensemble des requêtes portées devront voir leur plan d\u0026rsquo;exécution vérifié.
Le plan d\u0026rsquo;exécution de la requête sera vérifiée avec l\u0026rsquo;ordre EXPLAIN ANALYZE qui fournit non seulement le plan d\u0026rsquo;exécution en précisant les estimations de sélectivité réalisées par l\u0026rsquo;optimiseur, mais va également exécuter la requête et fournir la sélectivité réelle de chaque nœud du plan d\u0026rsquo;exécution. Une forte divergence entre la sélectivité estimée et réelle permet de détecter un problème. Souvent, il s\u0026rsquo;agit d\u0026rsquo;un problème de précision des statistiques. Il est possible d\u0026rsquo;agir sur cette précision de plusieurs manières.
Tout d\u0026rsquo;abord, il est possible d\u0026rsquo;augmenter le nombre d\u0026rsquo;échantillons collectés, pour construire notamment les histogrammes. Le paramètre default_statistics_target contrôle la précision de cet échantillon. Pour une base de forte volumétrie, ce paramètre sera augmenté systématiquement dans une proportion raisonnable. Pour une base de volumétrie normale, ce paramètre sera plutôt augmenté en ciblant une colonne particulière avec l\u0026rsquo;ordre SQL ALTER TABLE ... ALTER COLUMN ... SET STATISTICS ...;. De plus, il est possible de forcer artificiellement le nombre de valeurs distinctes d\u0026rsquo;une colonne avec l\u0026rsquo;ordre SQL ALTER TABLE ... SET COLUMN ... SET n_distinct = ...;. Il est aussi souvent utile d\u0026rsquo;envisager une réécriture de la requête : si l\u0026rsquo;optimiseur, sous Oracle comme sous PostgreSQL, n\u0026rsquo;arrive pas à trouver un bon plan, c\u0026rsquo;est probablement qu\u0026rsquo;elle est écrite d\u0026rsquo;une façon qui empêche ce dernier de travailler correctement.
`}),e.add({id:10,href:"/from-oracle-to-postgresql/fr/reprise-des-vues/",title:"Reprise des vues",section:"Portage du schéma",content:` Reprise des vues # Les vues simples sont portées sans difficultés sur PostgreSQL.
PostgreSQL supporte également les vues que l\u0026rsquo;on peut mettre à jour (updatable views), y compris avec la clause WITH CHECK OPTION qui permet de s\u0026rsquo;assurer que des données insérées ou mises à jour dans la vue satisfont toujours les éventuelles conditions de sélection de cette vue.
Références :
CREATE VIEW Vues XML # Certaines vues retournent le résultat au format XML. Le portage est assez rapide. Seule la fonction XMLELEMENT n\u0026rsquo;est pas compatible entre Oracle et PostgreSQL, il est nécessaire d\u0026rsquo;ajouter la directive name, qui devient le nom de l\u0026rsquo;élément XML pour PostgreSQL.
Ainsi, la définition de la vue suivante pour Oracle :
CREATE VIEW warehouse_view OF XMLTYPE XMLSCHEMA \u0026#34;http://www.oracle.com/xwarehouses.xsd\u0026#34; ELEMENT \u0026#34;Warehouse\u0026#34; WITH OBJECT ID (extract(OBJECT_VALUE, \u0026#39;/Warehouse/Area/text()\u0026#39;).getnumberval()) AS SELECT XMLELEMENT(\u0026#34;Warehouse\u0026#34;, XMLFOREST(WarehouseID AS \u0026#34;Building\u0026#34;, area AS \u0026#34;Area\u0026#34;, docks AS \u0026#34;Docks\u0026#34;, docktype AS \u0026#34;DockType\u0026#34;, wateraccess AS \u0026#34;WaterAccess\u0026#34;, railaccess AS \u0026#34;RailAccess\u0026#34;, parking AS \u0026#34;Parking\u0026#34;, VClearance AS \u0026#34;VClearance\u0026#34;)) FROM warehouse_table; sera transposée de cette façon pour PostgreSQL :
CREATE VIEW warehouse_view SELECT XMLELEMENT(name \u0026#34;Warehouse\u0026#34;, XMLFOREST(WarehouseID AS \u0026#34;Building\u0026#34;, area AS \u0026#34;Area\u0026#34;, docks AS \u0026#34;Docks\u0026#34;, docktype AS \u0026#34;DockType\u0026#34;, wateraccess AS \u0026#34;WaterAccess\u0026#34;, railaccess AS \u0026#34;RailAccess\u0026#34;, parking AS \u0026#34;Parking\u0026#34;, VClearance AS \u0026#34;VClearance\u0026#34;)) FROM warehouse_table; Références :
CREATE VIEW Vues matérialisées # Les vues matérialisées existent dans PostgreSQL et se comportent globalement de la même manière qu\u0026rsquo;avec Oracle. Néanmoins le rafraîchissement des vues n\u0026rsquo;est possible qu\u0026rsquo;à la demande (sur commande REFRESH MATERIALZED VIEW) et reconstruit totalement la vue.
Ainsi, une vue créée vide par exemple avec :
CREATE MATERIALIZED VIEW emp_aggr_mv BUILD DEFERRED REFRESH FORCE ON DEMAND AS SELECT deptno, SUM(sal) AS sal_by_dept FROM emp GROUP BY deptno; sera traduite en :
CREATE MATERIALIZED VIEW emp_aggr_mv AS SELECT deptno, SUM(sal) AS sal_by_dept FROM emp GROUP BY deptno WITH NO DATA; Les journaux de vues matérialisées et autres comportements avancées comme le rafraîchissement ON COMMIT ne sont pas encore implémentés avec PostgreSQL. L\u0026rsquo;émulation du rafraîchissement nécessite d\u0026rsquo;opter pour l\u0026rsquo;usage de triggers ou d\u0026rsquo;outils externes comme l\u0026rsquo;extension pg_ivm.
Références :
vues matérialisées pg_ivm `}),e.add({id:11,href:"/from-oracle-to-postgresql/fr/structures-de-controles/",title:"Structures de contrôles",section:"Portage du code PL/SQL vers PL/pgSQL",content:` Structures de contrôles # Les boucles et les différentes structures de contrôles ne nécessitent pas de portage particulier, en dehors des instructions GOTO et FORALL.
Boucle FOR REVERSE # La boucle FOR ... REVERSE présente également la particularité de devoir inverser les bornes min et max dans les boucles FOR ... IN ... REVERSE min..max.
Le code Oracle est le suivant :
FOR i IN REVERSE 1..10 BY 2 LOOP ... END LOOP; Il devra être modifié de la façon suivante :
FOR i IN REVERSE 10..1 BY 2 LOOP ... END LOOP; Une autre différence importante concerne les boucles FOR sur des requêtes (autres que des curseurs). Dans le code PL/SQL, sous Oracle, les variables cibles sont déclarées implicitement. Pour adapter une telle fonction à PostgreSQL, il est nécessaire de déclarer les variables cibles dans le bloc DECLARE de la fonction portée. Cela a également pour avantage de laisser cette variable accessible à la sortie de la boucle.
Ainsi, l\u0026rsquo;extrait de code PL/SQL suivant :
DECLARE v_date1 DATE, v_date2 DATE; BEGIN FOR r IN ( SELECT numberprgn FROM t2 WHERE status = \u0026#39;ordered\u0026#39; AND assigned_dept = \u0026#39;departt\u0026#39; ) LOOP SELECT min(datestamp) INTO v_date1 FROM T1 WHERE NUMBER = r.numberprgn AND description = \u0026#39;etat1\u0026#39;; SELECT min(datestamp) INTO v_date2 FROM T1 WHERE NUMBER = r.numberprgn AND description = \u0026#39;etat2\u0026#39;; END LOOP; sera porté de la façon suivante, en supposant que les variables v_date1 et v_date2 doivent être portées en type TIMESTAMP :
DECLARE v_date1 DATE, v_date2 TIMESTAMP; r record; BEGIN FOR r IN ( SELECT numberprgn FROM t2 WHERE status = \u0026#39;ordered\u0026#39; AND assigned_dept = \u0026#39;departt\u0026#39; ) LOOP SELECT min(datestamp) INTO STRICT v_date1 FROM T1 WHERE number = r.numberprgn AND description = \u0026#39;etat1\u0026#39;; SELECT min(datestamp) INTO STRICT v_date2 FROM T1 WHERE number = r.numberprgn AND description = \u0026#39;etat2\u0026#39;; END LOOP; Références :
boucle FOR Portage d\u0026rsquo;Oracle PL/SQL Instruction GOTO # L\u0026rsquo;instruction GOTO n\u0026rsquo;a pas d\u0026rsquo;équivalent sous PostgreSQL et nécessite une réécriture de code. L\u0026rsquo;usage de cette instruction est souvent déconseillée, mais il n\u0026rsquo;est pas rare de la retrouver pour contrôler d\u0026rsquo;exécution d\u0026rsquo;une boucle, par exemple pour aller à l\u0026rsquo;itération suivante ou simplement sortir de la boucle.
Ainsi, le code PL/SQL suivant :
LOOP FETCH curs_courant INTO courant; EXIT WHEN curs_courant%NOTFOUND; IF v_cat = \u0026#39;YYY\u0026#39; THEN v_cat := courant; GOTO DEBUT; END IF; IF courant = \u0026#39;N1\u0026#39; THEN v_cat := courant; GOTO FIN; END IF; ... \u0026lt;\u0026lt;DEBUT\u0026gt;\u0026gt; NULL; END LOOP; \u0026lt;\u0026lt;FIN\u0026gt;\u0026gt; CLOSE curs_courant; nécessitera d\u0026rsquo;être réécrit de la façon suivante :
LOOP FETCH curs_courant INTO courant; IF NOT FOUND THEN EXIT; END IF; IF v_cat = \u0026#39;YYY\u0026#39; THEN v_cat := courant; CONTINUE; END IF; IF courant = \u0026#39;N1\u0026#39; THEN v_cat := courant; EXIT; END IF; ... END LOOP; CLOSE curs_courant; Boucles FORALL # L\u0026rsquo;instruction FORALL n\u0026rsquo;a pas d\u0026rsquo;équivalent dans PostgreSQL. La boucle FORALL, utilisée pour parcourir les lignes d\u0026rsquo;une collection sous Oracle, n\u0026rsquo;existe pas non plus sous PostgreSQL. Cependant, son implémentation sous PostgreSQL est simple car il s\u0026rsquo;agit uniquement de parcourir le tableau de la collection.
Ainsi, la procédure PL/SQL suivante :
CREATE OR REPLACE PROCEDURE allEmployees IS TYPE v_array IS varray(50) OF CHAR(14); arr_emp v_array; BEGIN SELECT ename BULK COLLECT INTO arr_emp FROM emp ORDER BY ename; FORALL i IN 1..arr_emp.COUNT dbms_output.put_line(\u0026#39;|name\u0026#39;||arr_emp..(i)||\u0026#39;i\u0026#39;|| i); END allEmployees; sera réécrite de la façon suivante :
CREATE OR REPLACE FUNCTION allEmployees() RETURNS VOID AS $body$ DECLARE arr_emp CHAR(14)[]; BEGIN arr_emp := array ( SELECT ename FROM emp ORDER BY ename); FOR i IN array_lower(arr_emp,1)..array_upper(arr_emp,1) LOOP RAISE NOTICE \u0026#39;|name % i %\u0026#39;, arr_emp[i], i; END LOOP; END; $body$ LANGUAGE plpgsql; `}),e.add({id:12,href:"/from-oracle-to-postgresql/fr/portage-du-code-pl-sql-vers-pl-pgsql/",title:"Portage du code PL/SQL vers PL/pgSQL",section:"Docs",content:` Portage du code PL/SQL vers PL/pgSQL # Principales différences entre PL/SQL et PL/pgSQL # Bien que le SGBD Oracle supporte également la programmation Java côté serveur, et le SGBD PostgreSQL de nombreux langages (PL/Perl, PL/Python, PL/R, etc.), cette partie ne traite que du portage du PL/SQL en code PL/pgSQL.
Le langage PL/pgSQL de PostgreSQL est conçu à l\u0026rsquo;origine pour être ressemblant au langage PL/SQL d\u0026rsquo;Oracle. Cependant, ce sont deux langages différents qui nécessitent un certain travail pour passer de l\u0026rsquo;un à l\u0026rsquo;autre.
Tout d\u0026rsquo;abord, on note l\u0026rsquo;absence de package dans PostgreSQL. Il est donc nécessaire d\u0026rsquo;utiliser un moyen de contournement pour émuler leur fonctionnement.
Principales différences :
pas de packages ; code compilé à la première exécution, pas de façon globale ; contrairement aux fonctions, les procédures ne peuvent pas retourner de données ; pas de transaction autonome ; pas de fonctionnalités comme les directories… PL/PgSQL ne manipule pas de fichiers. Pour ce dernier point, les autres langages PL comblent ce manque (et plus). Il est aussi à noter que le langage d\u0026rsquo;écriture de la fonction est transparent pour l\u0026rsquo;appelant.
Portage des packages # Un package Oracle, ou paquet de fonctions, est le regroupement logique de variables et de procédures stockées. Il n\u0026rsquo;existe pas de notion de paquets de fonctions dans PostgreSQL. Pour simplifier le portage, Ora2Pg va créer un schéma portant le nom du paquet et importer les fonctions dans ce schéma. Ceci permet de garder la notation Oracle PACKAGE.PROCEDURE qui sera en fait sous PostgreSQL SCHEMA.FONCTION.
Oracle permet également de définir des fonctions à l\u0026rsquo;intérieur d\u0026rsquo;autres fonctions. PostgreSQL ne le permet pas avec PL/PgSQL. Elles devront être extraites du corps de leur fonction parente et déclarées comme les autres fonctions.
La notion de variable globale n\u0026rsquo;existe pas sous PL/PgSQL. Pour pouvoir émuler le comportement des variables globales, on peut utiliser les variables utilisateurs, qu\u0026rsquo;il faudra définir dans le fichier de configuration postgresql.conf, au niveau de la base, de l\u0026rsquo;utilisateur ou de la session.
Celles-ci doivent être préfixée par un espace de nom au choix, pour ne pas rentrer en conflit avec les variables systèmes. Une bonne pratique consiste à préfixer une variable par le nom du schéma qui imite le package. La variable reste locale à une session et ne persiste pas à sa fermeture ni ne peut se partager entre plusieurs sessions.
Par exemple, pour créer une variable globale nommée id_region, il suffit d\u0026rsquo;utiliser la commande SET :
SET monschema.id_region = \u0026#39;38\u0026#39;; et pour utiliser sa valeur dans la même session :
SELECT current_setting(\u0026#39;monschema.id_region\u0026#39;) AS id_region; Il est également possible d\u0026rsquo;utiliser la fonction set_config à l\u0026rsquo;intérieur d\u0026rsquo;une fonction PL/pgSQL. Le troisième paramètre de la méthode permet de déterminer si la variable est locale à la transaction ou globale dans la session.
PERFORM set_config(\u0026#39;monschema.id_region\u0026#39;, \u0026#39;38\u0026#39;, false); Dans un bloc PL/pgSQL, la méthode current_setting peut être directement employée pour assignée la valeur dans une variable ou à travers le mot-clé INTO.
a := current_setting(\u0026#39;monschema.id_region\u0026#39;); Il est également possible d\u0026rsquo;utiliser une table pour définir ces variables et leurs valeurs. Par ailleurs, certains langages PL, comme PL/Perl par exemple, disposent quant à eux, de variables globales.
`}),e.add({id:13,href:"/from-oracle-to-postgresql/fr/reprise-des-sequences/",title:"Reprise des séquences",section:"Portage du schéma",content:` Reprise des séquences # La reprise des séquences ne nécessite pas un travail important. Les séquences sont implémentées de la même façon dans PostgreSQL et dans Oracle. Cependant, certains points nécessitent un peu d\u0026rsquo;attention.
De manière générale, les clauses précédées de NO permettant d\u0026rsquo;utiliser les valeurs par défaut nécessitent de séparer le mot clé NO de la clause pour être porté sous PostgreSQL. Par exemple, la clause NOMAXVALUE Oracle doit être réécrite NO MAXVALUE pour PostgreSQL. Toutefois, la clause Oracle NOCACHE n\u0026rsquo;a pas d\u0026rsquo;équivalent direct dans PostgreSQL, mais on peut la transformer en CACHE 1 ou simplement la supprimer. Seules les clauses ORDER et NOORDER ne trouveront aucun équivalent dans PostgreSQL car elles sont spécifiques à Oracle RAC.
Références :
CREATE SEQUENCE Utilisation des séquences # Les séquences ne s\u0026rsquo;utilisent pas de la même manière avec Oracle qu\u0026rsquo;avec PostgreSQL. Oracle a une syntaxe nom_sequence.operation tandis que PostgreSQL a une syntaxe operation('nom_sequence').
Par exemple, l\u0026rsquo;appel suivant, valide sous Oracle :
nom_sequence.nextval sera transposé de la façon suivante sous PostgreSQL :
nextval(\u0026#39;nom_sequence\u0026#39;) Références :
CREATE SEQUENCE Fonctions de manipulation de séquences `}),e.add({id:14,href:"/from-oracle-to-postgresql/fr/reprise-du-code-pl-sql/",title:"Reprise du code PL/SQL",section:"Portage du code PL/SQL vers PL/pgSQL",content:` Reprise du code PL/SQL # Chaînes vides et valeur NULL # Pour Oracle, une chaîne vide est aussi une valeur NULL. Le SGBD PostgreSQL fait la différence : soit la chaîne est nulle (IS NULL) soit elle est vide.
Certaines requêtes donnant satisfaction sous Oracle peuvent donner des résultats faux lorsqu\u0026rsquo;elles sont portées directement. Les cas les plus courants sont la comparaison de la valeur d\u0026rsquo;une colonne avec une chaîne vide et la concaténation avec une valeur NULL. Il est nécessaire de se reporter à la partie concernant le portage des requêtes pour le traitement de ces deux cas.
Lorsque l\u0026rsquo;on porte du code PL/SQL en PL/pgSQL, il faut faire attention au code qui l\u0026rsquo;appelle, côté applicatif : si le développeur de l\u0026rsquo;application n\u0026rsquo;a pas pris garde de migrer les '' par des NULL, alors il faut prévoir le cas où la fonction reçoit des chaînes vides en lieu et place de la valeur NULL.
Ainsi, les codes Oracle suivant peuvent poser des problèmes du fait de cette confusion entre la chaîne vide et la valeur NULL :
IF vidtarif IS NULL THEN ... IF vidtarif IS NOT NULL THEN ... Pour Oracle, vidtarif sera NULL si elle est une chaine vide ou si elle est à NULL, et ce, indifféremment. Si le code appelle une fonction qui a ce type de traitement, mais en lui passant des chaînes vides en argument, cela fonctionnera avec Oracle.
Mais il en sera tout autrement avec PostgreSQL. Ce dernier est beaucoup plus strict. Il faut donc étendre les tests dans le code migré en PL/pgSQL sous PostgreSQL, pour se prémunir de toute écriture non migré dans l\u0026rsquo;application.
Voici un exemple de portage du premier test donné en exemple plus haut :
IF COALESCE(vidtarif, \u0026#39;\u0026#39;) = \u0026#39;\u0026#39; THEN ... Dans cet exemple, si vidtarif est NULL, alors coalesce va choisir la valeur suivante, soit la chaine vide ''. L\u0026rsquo;égalité sera alors vraie. Et si vidtarif est une chaine vide, l\u0026rsquo;égalité sera vraie aussi.
Concernant le second test IS NOT NULL vu plus haut, son portage est plus subtil :
IF (vidtarif IS NOT NULL AND vidtarif \u0026lt;\u0026gt; \u0026#39;\u0026#39;) THEN ... Il est également possible d\u0026rsquo;utiliser l\u0026rsquo;astuce suivante en début de fonction, ce qui simplifiera grandement l\u0026rsquo;écritures des conditions. Ceci ne s\u0026rsquo;applique pas à SQL cependant, uniquement à PL/SQL.
IF vidtarif = \u0026#39;\u0026#39; THEN vidtarif := NULL END; Ora2Pg fait ces conversions de code automatiquement par défaut, la directive NULL_EQUAL_EMPTY permet de désactiver ce comportement.
Exécution de requêtes et de fonctions # Lorsqu\u0026rsquo;un SELECT sans clause INTO est présent, il doit être remplacé par PERFORM. Cette transformation est également prise en charge par Ora2Pg.
Ainsi, l\u0026rsquo;extrait suivant d\u0026rsquo;une procédure PL/SQL :
BEGIN SELECT ename, sal FROM EMP WHERE empno=7902 FOR UPDATE; ... END; sera réécrit de la façon suivante :
BEGIN PERFORM ename, sal FROM EMP WHERE empno=7902 FOR UPDATE; ... END; Par ailleurs, l\u0026rsquo;instruction EXEC permettant de récupérer le code retour d\u0026rsquo;une fonction PL/SQL dans une variable n\u0026rsquo;existe pas dans PostgreSQL. Il faut la réécrire en utilisant l\u0026rsquo;instruction SELECT INTO. Cette transformation est prise en charge par Ora2Pg.
Ainsi, l\u0026rsquo;extrait de code PL/SQL ci-dessous :
EXEC :a := get_version(); sera réécrit de la façon suivante :
SELECT get_version() INTO a; Exécution de requêtes dynamiques # Oracle a un ordre EXECUTE IMMEDIATE pour exécuter une requête construite dynamiquement. Dans PostgreSQL, le mot clé IMMEDIATE doit être supprimé car il n\u0026rsquo;est pas supporté. En effet, un ordre EXECUTE est toujours réalisé immédiatement. Cette transformation est réalisée par Ora2Pg.
Par ailleurs, il est préférable de modifier la construction de l\u0026rsquo;ordre SQL dynamique pour utiliser les fonctions quote_literal et quote_ident de PostgreSQL, respectivement pour encadrer les valeurs littérales et les identifiants (noms d\u0026rsquo;objets). Cette adaptation permet de se protéger des injections SQL. Elle n\u0026rsquo;est pas prise en charge par Ora2Pg.
Par exemple, l\u0026rsquo;extrait de code SQL suivant :
sql_stmt := \u0026#39;UPDATE employees SET salary = salary + :1 WHERE \u0026#39; || v_column || \u0026#39; = :2\u0026#39;; EXECUTE IMMEDIATE sql_stmt USING amount, column_value; devrait être porté de la façon suivante (à noter également, les : remplacés par $) :
sql_stmt := \u0026#39;UPDATE employees SET salary = salary + $1 WHERE \u0026#39; || quote_literal(v_column) || \u0026#39; = $2\u0026#39;; EXECUTE sql_stmt USING amount, column_value; Références :
Exécution dynamique de commandes COMMIT dans une routine # Il n\u0026rsquo;est pas possible de coder des instructions de validation/invalidation de la transaction courante, COMMIT/ROLLBACK, dans une fonction ou dans une procédure appelée par une fonction.
Dans ces cas de figure il convient de remonter la gestion de la transaction dans du code de niveau supérieur.
Notons que, de par sa gestion du MVCC, PostgreSQL peut supporter des longues transactions plus facilement qu\u0026rsquo;Oracle. Aussi, certaines instructions de COMMIT intermédiaires peuvent souvent être purement et simplement supprimées.
Gestion des exceptions # Le traitement des exceptions diffère quelque peu entre Oracle et PostgreSQL. La variable SQLCODE d\u0026rsquo;Oracle est le presque équivalent de SQLSTATE dans PostgreSQL. Il est donc nécessaire de transformer SQLCODE en SQLSTATE, ce que fait Ora2Pg.
Oracle et PostgreSQL sont fondamentalement différents dans le traitement des exceptions. La différence la plus notable est la façon dont l\u0026rsquo;erreur est gérée. Si une erreur est déclenchée dans un bloc PL/SQL, seule l\u0026rsquo;instruction déclenchante est annulée. En conséquence, on voit souvent des points de sauvegarde déclarés au début du bloc et des instructions ROLLBACK TO SAVEPOINT émises dans le bloc d\u0026rsquo;exception.
Avec PostgreSQL, quand une exception est récupérée par une clause EXCEPTION, toutes les modifications de la base de données depuis le bloc BEGIN sont automatiquement annulées. C\u0026rsquo;est un point important à prendre en compte quant au portage d\u0026rsquo;une fonction ou d\u0026rsquo;une procédure PL/SQL.
Dans ce cas, des constructions PL/SQL utilisant des SAVEPOINT seront portés très simplement en supprimant les instructions de traitements des points de reprises.
Ainsi, le code PL/SQL suivant :
BEGIN SAVEPOINT s1; ... EXCEPTION WHEN ... THEN ROLLBACK TO s1; ... WHEN ... THEN ROLLBACK TO s1; ... END; sera traduit de la façon suivante en PL/pgSQL :
BEGIN ... EXCEPTION WHEN ... THEN ... WHEN ... THEN ... END; Le nom de certaines exceptions doit être transposé. Le tableau ci-dessous donne les correspondances entre les exceptions Oracle et les exceptions PostgreSQL qu\u0026rsquo;il est nécessaire de modifier :
Exception Oracle Exception PostgreSQL STORAGE_ERROR OUT_OF_MEMORY ZERO_DIVIDE DIVISION_BY_ZERO INVALID_CURSOR INVALID_CURSOR_STATE dup_val_on_index unique_violation Enfin, la fonction Oracle raise_application_error doit être transformée en RAISE EXCEPTION. Le code Oracle suivant :
raise_application_error( -20000, \u0026#39;Unable to create a new job: a job is currently running.\u0026#39; ); doit être transposé de la façon suivante :
RAISE EXCEPTION \u0026#39;Unable to create a new job: a job is currently running\u0026#39;; Références :
Codes d\u0026rsquo;erreurs de PostgreSQL Annulation implicite après une exception SELECT INTO # L\u0026rsquo;instruction SELECT ... INTO ... nécessite d\u0026rsquo;être adaptée pour qu\u0026rsquo;elle se comporte sous PostgreSQL de la même façon qu\u0026rsquo;elle le ferait sous Oracle. En effet, la documentation de PostgreSQL indique : « L\u0026rsquo;option STRICT correspond au comportement du SELECT INTO d\u0026rsquo;Oracle PL/SQL et des instructions relatives. ».
Il est donc nécessaire d\u0026rsquo;ajouter le mot clé STRICT après INTO lorsqu\u0026rsquo;une exception sur NO_DATA_FOUND ou TOO_MANY_ROWS est traitée dans le même bloc de code.
Ainsi, l\u0026rsquo;extrait suivant d\u0026rsquo;une procédure PL/SQL Oracle :
BEGIN SELECT idgroupetarif INTO vgroupevente FROM groupetarif WHERE classetarif = \u0026#39;V\u0026#39; AND isdefaut = 1 AND ispublic = vispublic; EXCEPTION WHEN NO_DATA_FOUND THEN vidartpxvte := \u0026#39;-040\u0026#39;; RETURN vidartpxvte; WHEN TOO_MANY_ROWS THEN vidartpxvte := \u0026#39;-045\u0026#39;; RETURN vidartpxvte; END; doit être migré de la façon suivante pour PostgreSQL :
BEGIN SELECT idgroupetarif INTO STRICT vgroupevente FROM groupetarif WHERE classetarif = \u0026#39;V\u0026#39; AND isdefaut = 1 AND ispublic = vispublic; EXCEPTION WHEN NO_DATA_FOUND THEN vidartpxvte := \u0026#39;-040\u0026#39;; RETURN vidartpxvte; WHEN TOO_MANY_ROWS THEN vidartpxvte := \u0026#39;-045\u0026#39;; RETURN vidartpxvte; END; Références :
Exécuter une requête avec une seule ligne de résultats BULK COLLECT # La notion de BULK COLLECT n\u0026rsquo;existe pas sous PostgreSQL. Cette fonctionnalité d\u0026rsquo;Oracle charge le résultat d\u0026rsquo;une requête dans un tableau et permet de parcourir ensuite ce tableau.
Par exemple, ce code Oracle :
CREATE PROCEDURE tousLesAuteurs IS TYPE my_array IS varray(100) OF VARCHAR(25); temp_arr my_array; BEGIN SELECT nom BULK COLLECT INTO temp_arr FROM auteurs ORDER BY nom; FOR i IN temp_arr.first .. temp_arr.last LOOP DBMS_OUTPUT.put_line(i || \u0026#39;) nom: \u0026#39; || temp_arr..(i)); END LOOP; END tousLesAuteurs; peut être traduit sous PostgreSQL de la façon suivante :
CREATE FUNCTION tousLesAuteurs() RETURNS VOID AS $$ DECLARE temp_arr VARCHAR(25)[]; BEGIN temp_arr := (SELECT nom FROM auteurs ORDER BY nom); FOR i IN array_lower(temp_arr,1) .. array_upper(temp_arr,1) LOOP RAISE NOTICE \u0026#39;% ) nom: %\u0026#39;, i, temp_arr..(i); END LOOP; END; $$ LANGUAGE plpgsql; Fonction instr # Oracle propose une fonction instr. La documentation de PostgreSQL propose une implémentation en PL/pgSQL équivalente, dans l\u0026rsquo;annexe de la section concernant le portage de PL/SQL vers PL/pgSQL.
`}),e.add({id:15,href:"/from-oracle-to-postgresql/fr/traitement-des-hierarchies/",title:"Traitement des hiérarchies",section:"Portage des requêtes SQL",content:` Traitement des hiérarchies # Oracle propose la fonction CONNECT BY qui permet d\u0026rsquo;explorer un arbre hiérarchique. Cette fonction spécifique à Oracle possède des fonctionnalités avancées comme la détection de cycle et propose des pseudos-colonnes comme le niveau de la hiérarchie et la construction d\u0026rsquo;un chemin.
Depuis la version 14 de PostgreSQL, il est possible de porter de nouvelles fonctionnalités avancées. Pour les versions antérieurs, un travail important de portage doit être réalisé pour porter les requêtes utilisant cette clause.
CONNECT BY # Soit la requête SQL suivante qui explore la hiérarchie de la table emp. La colonne mgr de cette table désigne le responsable hiérarchique d\u0026rsquo;un employé. Si elle vaut NULL, alors la personne est au sommet de la hiérarchie (START WITH mgr IS NULL). Le lien avec l\u0026rsquo;employé et son responsable hiérarchique est construit avec la clause CONNECT BY PRIOR empno = mgr qui indique que la valeur de la colonne mgr correspond à l\u0026rsquo;identifiant empno du niveau de hiérarchie précédent.
SELECT empno, ename, job, mgr FROM emp START WITH mgr IS NULL CONNECT BY PRIOR empno = mgr Le portage de cette requête est réalisé à l\u0026rsquo;aide d\u0026rsquo;une requête récursive (WITH RECURSIVE). La récursion est initialisée dans une première requête qui récupère les lignes qui correspondent à la condition de la clause START WITH de la requête précédente : mgr IS NULL. La récursion continue ensuite avec la requête suivante qui réalise une jointure entre la table emp et la vue virtuelle emp_hierarchy qui est définie par la clause WITH RECURSIVE. La condition de jointure correspond à la clause CONNECT BY. La vue virtuelle emp_hierarchy a pour alias prior pour mieux représenter la transposition de la clause CONNECT BY.
La requête récursive pour PostgreSQL serait alors écrite de la façon suivante :
WITH RECURSIVE emp_hierarchy (empno, ename, job, mgr) AS ( SELECT empno, ename, job, mgr FROM emp WHERE mgr IS NULL UNION ALL SELECT emp.empno, emp.ename, emp.job, emp.mgr FROM emp JOIN emp_hierarchy prior ON (emp.mgr = prior.empno) ) SELECT * FROM emp_hierarchy; Il faudra néanmoins faire attention à l\u0026rsquo;ordre des lignes qui sera différent avec la requête WITH RECURSIVE. En effet, Oracle utilise un algorithme depth-first dans son implémentation du CONNECT BY. Ainsi, il explorera d\u0026rsquo;abord chaque branche avant de passer à la suivante. L\u0026rsquo;implémentation WITH RECURSIVE est de type breadth-first qui explore chaque niveau de hiérarchie avant de descendre.
Il est possible de retrouver l\u0026rsquo;ordre de tri d\u0026rsquo;une requête CONNECT BY pour une version antérieure à la 11g d\u0026rsquo;Oracle en triant sur une colonne path, telle qu\u0026rsquo;elle est construite pour émuler la clause SYS_CONNECT_BY_PATH :
WITH RECURSIVE emp_hierarchy (empno, ename, job, mgr, path) AS ( SELECT empno, ename, job, mgr, ARRAY[ename::TEXT] AS path FROM emp WHERE mgr IS NULL UNION ALL SELECT emp.empno, emp.ename, emp.job, emp.mgr, prior.path || emp.ename::TEXT AS path FROM emp JOIN emp_hierarchy prior ON (emp.mgr = prior.empno) ) SELECT empno, ename, job FROM emp_hierarchy AS emp ORDER BY path; À partir de la version 11g, Oracle retourne les résultats dans un ordre différent.
Pseudo-colonne LEVEL # La clause LEVEL permet d\u0026rsquo;obtenir le niveau de hiérarchie d\u0026rsquo;un élément.
SELECT empno, ename, job, mgr, level FROM emp START WITH mgr IS NULL CONNECT BY PRIOR empno = mgr Le portage de la clause LEVEL est facile. La requête d\u0026rsquo;initialisation de la récursion initialise la colonne level à 1. La requête de récursion effectue ensuite une incrémentation de cette colonne pour chaque niveau de hiérarchie exploré :
WITH RECURSIVE emp_hierarchy (empno, ename, job, mgr, level) AS ( SELECT empno, ename, job, mgr, 1 AS level FROM emp WHERE mgr IS NULL UNION ALL SELECT emp.empno, emp.ename, emp.job, emp.mgr, prior.level + 1 FROM emp JOIN emp_hierarchy prior ON (emp.mgr = prior.empno) ) SELECT * FROM emp_hierarchy; Clause SYS_CONNECT_BY_PATH # La clause SYS_CONNECT_BY_PATH permet d\u0026rsquo;obtenir un chemin où chaque élément est séparé de l\u0026rsquo;autre par un caractère donné. Par exemple, la requête suivante indique qui sont les différents responsables d\u0026rsquo;un employé de cette façon :
SELECT empno, ename, job, mgr, SYS_CONNECT_BY_PATH(ename, \u0026#39;/\u0026#39;) AS path FROM emp START WITH mgr IS NULL CONNECT BY PRIOR empno = mgr; Le portage de la clause SYS_CONNECT_BY_PATH est également assez facile. La requête d\u0026rsquo;initialisation de la récursion construit l\u0026rsquo;élément racine : '/' || ename AS path. La requête de récursion réalise quant à elle une concaténation entre le path récupéré de la précédente itération et l\u0026rsquo;élément à concaténé : prior.path || '/' || emp.ename :
WITH RECURSIVE emp_hierarchy (empno, ename, job, mgr, path) AS ( SELECT empno, ename, job, mgr, \u0026#39;/\u0026#39; || ename AS path FROM emp WHERE mgr IS NULL UNION ALL SELECT emp.empno, emp.ename, emp.job, emp.mgr, prior.path || \u0026#39;/\u0026#39; || emp.ename FROM emp JOIN emp_hierarchy prior ON (emp.mgr = prior.empno) ) SELECT * FROM emp_hierarchy; Une autre façon de faire est d\u0026rsquo;utiliser un tableau pour stocker le chemin le temps de la récursion, puis de construire la représentation textuelle de ces chemins au moment de la sortie des résultats. À noter la conversion de la valeur de ename en type text pour chaque élément ajouté dans le tableau path. Cette variante peut être utile pour l\u0026rsquo;émulation de la clause NOCYCLE comme vu plus bas :
WITH RECURSIVE emp_hierarchy (empno, ename, job, mgr, path) AS ( SELECT empno, ename, job, mgr, ARRAY[ename::TEXT] AS path FROM emp WHERE mgr IS NULL UNION ALL SELECT emp.empno, emp.ename, emp.job, emp.mgr, prior.path || emp.ename::TEXT AS path FROM emp JOIN emp_hierarchy prior ON (emp.mgr = prior.empno) ) SELECT empno, ename, job, array_to_string(path, \u0026#39;/\u0026#39;) AS path FROM emp_hierarchy AS emp; Clause NOCYCLE # La requête Oracle suivante :
SELECT empno, ename, job, mgr FROM emp START WITH mgr IS NULL CONNECT BY NOCYCLE PRIOR empno = mgr; sera transposée pour PostgreSQL de la façon suivante :
WITH RECURSIVE emp_hierarchy (empno, ename, job, mgr, path, is_cycle) AS ( SELECT empno, ename, job, mgr, ARRAY[ename::TEXT] AS path, false AS is_cycle FROM emp WHERE mgr IS NULL UNION ALL SELECT emp.empno, emp.ename, emp.job, emp.mgr, prior.path || emp.ename::TEXT AS path, emp.ename = ANY(prior.path) AS is_cycle FROM emp JOIN emp_hierarchy prior ON (emp.mgr = prior.empno) WHERE is_cycle = false ) SELECT empno, ename, job, mgr FROM emp_hierarchy AS emp WHERE is_cycle = false; Clause CONNECT_BY_IS_CYCLE # La clause CONNECT_BY_IS_CYCLE retourne 1 si la ligne courante a un enfant qui est également son ancêtre. Dans le cas contraire, elle retourne 0. Il est possible de retrouver le fonctionnement de cette clause à partir de la requête précédente, à l\u0026rsquo;aide d\u0026rsquo;une expression conditionnelle et en supprimant la dernière restriction :
WITH RECURSIVE emp_hierarchy (empno, ename, job, mgr, level, path, is_cycle) AS ( SELECT empno, ename, job, mgr, 1 AS level, ARRAY[ename::TEXT] AS path, false AS is_cycle FROM emp WHERE mgr = 10000 UNION ALL SELECT emp.empno, emp.ename, emp.job, emp.mgr, prior.level + 1 AS level, prior.path || emp.ename::TEXT AS path, emp.ename = ANY(prior.path) AS is_cycle FROM emp JOIN emp_hierarchy prior ON (emp.mgr = prior.empno) WHERE is_cycle = false ) SELECT *, is_cycle::int AS connect_by_is_cycle FROM emp_hierarchy AS emp; Clause ORDER SIBLINGS BY # L\u0026rsquo;émulation de la clause ORDER SIBLINGS BY, qui effectue un tri, nécessite de reprendre la requête récursive émulant la clause SYS_CONNECT_BY_PATH et d\u0026rsquo;appliquer un tri sur la colonne path résultante de la requête :
WITH RECURSIVE emp_hierarchy (empno, ename, job, mgr, path) AS ( SELECT empno, ename, job, mgr, \u0026#39;/\u0026#39; || ename AS path FROM emp WHERE mgr IS NULL UNION ALL SELECT emp.empno, emp.ename, emp.job, emp.mgr, prior.path || \u0026#39;/\u0026#39; || emp.ename FROM emp JOIN emp_hierarchy prior ON (emp.mgr = prior.empno) ) SELECT * FROM emp_hierarchy ORDER BY path; Cependant, cette émulation ne fonctionne que dans le cadre d\u0026rsquo;un tri ascendant. L\u0026rsquo;application d\u0026rsquo;un tri descendant ne retourne pas le résultat escompté.
Clause CONNECT_BY_ROOT # La clause CONNECT_BY_ROOT retourne la racine de chaque élément de la hiérarchie. Dans l\u0026rsquo;exemple ci-dessous, la dernière colonne retournera le nom de la personne la plus élevée dans la hiérarchie de l\u0026rsquo;employé concerné :
SELECT empno, ename, job, mgr AS direct_mgr, CONNECT_BY_ROOT ename AS mgr FROM emp START WITH mgr IS NULL CONNECT BY mgr = PRIOR empno ORDER SIBLINGS BY ename DESC; La requête est transposée de la même manière que pour le cas de SYS_CONNECT_BY_PATH. Le tableau path est utilisé pour obtenir l\u0026rsquo;élément racine de la hiérarchie.
WITH RECURSIVE emp_hierarchy (empno, ename, job, mgr, path) AS ( SELECT empno, ename, job, mgr, ARRAY[ename::TEXT] AS path FROM emp WHERE mgr IS NULL UNION ALL SELECT emp.empno, emp.ename, emp.job, emp.mgr, prior.path || emp.ename::TEXT AS path FROM emp JOIN emp_hierarchy prior ON (emp.mgr = prior.empno) ) SELECT empno, ename, job, path[1] AS connect_by_root FROM emp_hierarchy AS emp; Clause CONNECT_BY_ISLEAF # La clause CONNECT_BY_ISLEAF ne prend aucun argument et précise si la ligne en question (feuille) n\u0026rsquo;est plus connectée à une nouvelle ligne descendante à travers l\u0026rsquo;arbre de hiérarchie. La valeur 0 est retournée s\u0026rsquo;il existe une connexion et 1 s\u0026rsquo;il s\u0026rsquo;agit de la dernière ligne de la hiérarchie.
SELECT empno, ename, job, mgr, CONNECT_BY_ROOT ename AS mgr, CONNECT_BY_ISLEAF AS isleaf, SYS_CONNECT_BY_PATH(ename, \u0026#39;/\u0026#39;) AS path FROM emp START WITH mgr IS NULL CONNECT BY mgr = PRIOR empno L\u0026rsquo;émulation de la clause CONNECT_BY_ISLEAF nécessite une auto-jointure sur le résultat de la requête récursive pour déterminer si la ligne est une feuille de l\u0026rsquo;arbre. Il est nécessaire d\u0026rsquo;utiliser la colonne de type tableau path pour pouvoir trier le résultat.
WITH RECURSIVE emp_hierarchy (empno, ename, job, mgr, path) AS ( SELECT empno, ename, job, mgr, ARRAY[ename::TEXT] AS path FROM emp WHERE mgr IS NULL UNION ALL SELECT emp.empno, emp.ename, emp.job, emp.mgr, prior.path || emp.ename::TEXT AS path FROM emp JOIN emp_hierarchy prior ON (emp.mgr = prior.empno) ) SELECT emp.empno, emp.ename, emp.job, CASE WHEN leaf.empno IS NULL THEN 1 ELSE 0 END AS isleaf FROM emp_hierarchy AS emp LEFT JOIN emp_hierarchy AS leaf ON (emp.empno = leaf.mgr) ORDER BY emp.path; `}),e.add({id:16,href:"/from-oracle-to-postgresql/fr/curseurs/",title:"Curseurs",section:"Portage du code PL/SQL vers PL/pgSQL",content:` Curseurs # La notation des variables curseurs est quelque peu différente entre Oracle et PostgreSQL.
Déclaration des curseurs # Sous Oracle, on déclare un curseur de cette façon : CURSOR moncurseur. Il est nécessaire d\u0026rsquo;inverser cette déclaration pour la rendre compatible avec PostgreSQL : moncurseur CURSOR. Ce cas est traité par Ora2Pg.
Les curseurs de type REF CURSOR et SYS_REFCURSOR sous Oracle doivent également être modifiés en REFCURSOR sous PostgreSQL.
Sous Oracle, le mot clé IN dans la déclaration des curseurs permet de passer des paramètres au curseur. Ce mot clé est inutile avec PostgreSQL, il suffit de la supprimer.
La déclaration suivante pour Oracle :
CURSOR curs_lignes_commande(no_cde IN VARCHAR2) IS SELECT * FROM lignes_commande WHERE num_cde = no_cde; doit être transposé de cette façon pour PostgreSQL :
curs_lignes_commande CURSOR (no_cde VARCHAR) FOR SELECT * FROM lignes_commande WHERE num_cde = no_cde; Références :
Types record Retour d\u0026rsquo;un curseur # Le type retourné lors de la manipulation des curseurs est un enregistrement RECORD et non pas nom_curseur%ROWTYPE sous Oracle. Avec PostgreSQL, il est possible à la lecture du curseur de placer cet enregistrement dans une cible qui peut être une variable ligne, une variable record ou une liste de variables simples séparées par des virgules.
Par exemple, la déclaration d\u0026rsquo;une référence sur un curseur se fait de la façon suivante sous Oracle :
TYPE return_cur IS REF CURSOR RETURN ma_table%ROWTYPE; p_retcur return_cur; Alors que, sous PostgreSQL, cela s\u0026rsquo;écrit de la sorte :
return_cur REFCURSOR; Sortie d\u0026rsquo;un curseur # Enfin, le code de sortie d\u0026rsquo;un curseur doit être modifié. La construction Oracle EXIT WHEN ...%NOTFOUND n\u0026rsquo;est pas reconnue par PostgreSQL. Elle doit être remplacée par une construction de ce type : IF NOT FOUND THEN EXIT; END IF;. La construction SQL%NOTFOUND est également à remplacer par NOT FOUND. Ces deux transformations sont prises en compte par Ora2Pg.
L\u0026rsquo;extrait de code PL/SQL suivant :
LOOP FETCH c1 INTO my_ename, my_sal, my_hiredate; EXIT WHEN c1%NOTFOUND; ... END LOOP; doit être transposé de la façon suivante :
LOOP FETCH c1 INTO my_ename, my_sal, my_hiredate; IF NOT FOUND THEN EXIT; END IF; ... END LOOP; `}),e.add({id:17,href:"/from-oracle-to-postgresql/fr/gestion-des-transactions/",title:"Gestion des transactions",section:"Portage des requêtes SQL",content:` Gestion des transactions # La gestion des transactions et des verrous est assez similaire entre Oracle et PostgreSQL. Il faut noter deux différences majeures entre les deux SGBD. Tout d\u0026rsquo;abord, Oracle ouvre implicitement une transaction lorsque l\u0026rsquo;on commence à travailler, tandis que PostgreSQL travaille en autocommit par défaut. Il faut alors ouvrir explicitement une transaction avec l\u0026rsquo;ordre BEGIN.
L\u0026rsquo;autre différence majeure concerne l\u0026rsquo;implémentation du moteur MVCC de PostgreSQL qui permet d\u0026rsquo;avoir un coût nul pour les ROLLBACK dans PostgreSQL. En contrepartie, les blocs modifiés par une transaction qui effectue un ROLLBACK seront physiquement présents car le moteur de PostgreSQL aura malgré tout créé de nouvelles versions de ces lignes, bien qu\u0026rsquo;elles aient été annulées. Cet espace devra être récupéré ensuite par VACUUM.
L\u0026rsquo;ordre BEGIN a plusieurs déclinaisons synonymes :
BEGIN, BEGIN WORK, BEGIN TRANSACTION, START TRANSACTION. Références :
BEGIN START TRANSACTION Niveau d\u0026rsquo;isolation # Il est possible d\u0026rsquo;indiquer le niveau d\u0026rsquo;isolation d\u0026rsquo;une transaction en l\u0026rsquo;indiquant dans l\u0026rsquo;ordre d\u0026rsquo;ouverture d\u0026rsquo;une transaction :
BEGIN [ WORK | TRANSACTION ] [ mode_transaction [, ...] ] où mode_transaction est :
ISOLATION LEVEL {SERIALIZABLE | REPEATABLE READ | READ COMMITTED | READ UNCOMMITTED } READ WRITE | READ ONLY [ NOT ] DEFERRABLE READ UNCOMMITTED est un synonyme de READ COMMITTED sous PostgreSQL, tout comme sous Oracle : les moteurs étant MVCC, le mode READ UNCOMMITTED n\u0026rsquo;a pas d\u0026rsquo;intérêt (les écrivains ne bloquent pas les lecteurs, les lecteurs ne bloquent pas les écrivains).
Par ailleurs, Oracle et PostgreSQL implémentent un niveau d\u0026rsquo;isolation SERIALIZABLE. PostgreSQL implémente le niveau d\u0026rsquo;isolation SERIALIZABLE avec des verrous optimistes afin de garantir un meilleur débit transactionnel. La plupart des SGBD implémentent ce niveau d\u0026rsquo;isolation par le biais de verrous pessimistes, grevant ainsi les performances.
Oracle permet de positionner le niveau d\u0026rsquo;isolation des transactions pour une session donnée, c\u0026rsquo;est-à-dire que toutes les transactions réalisées dans la même session.
L\u0026rsquo;ordre SQL suivant permet de positionner le niveau d\u0026rsquo;isolation au niveau de la session pour Oracle :
ALTER SESSION SET ISOLATION LEVEL ...; La même chose est possible avec PostgreSQL au niveau d\u0026rsquo;un bloc transactionnel :
BEGIN TRANSACTION ISOLATION LEVEL ...; ... COMMIT; La façon pour PostgreSQL de déterminer les violations de sérialisations est plus stricte que celle d\u0026rsquo;Oracle, mais les deux modes sont très similaires. Par exemple, l\u0026rsquo;article \u0026ldquo;On Transaction Isolation Levels\u0026rdquo; reprend une succession d\u0026rsquo;instructions entre deux sessions, valides avec Oracle (Tableau 7), qui provoque une erreur dans PostgreSQL.
create table a ( x int ); create table b ( x int ); Time Session #1 Session #2 t1 ALTER SESSION SET isolation_level=serializable; t2 ALTER SESSION SET isolation_level=serializable; t3 INSERT INTO a SELECT count(*) FROM b; t4 INSERT INTO b SELECT count(*) FROM a; t5 COMMIT; t6 COMMIT; PostgreSQL n\u0026rsquo;autorise pas la session #2 à valider ces modifications à cause d\u0026rsquo;une violation de son instantané (snapshot). Un message d\u0026rsquo;erreur est ainsi levé en suggérant de recommencer la transaction pour aboutir correctement.
ERROR: could not serialize access due to read/write dependencies among transactions DETAIL: Reason code: Canceled on identification as a pivot, during commit attempt. HINT: The transaction might succeed if retried. Références :
Isolation des transactions SET TRANSACTION Vérification des contraintes # Les contraintes d\u0026rsquo;intégrité sont vérifiées à chaque instruction d\u0026rsquo;écriture, qu\u0026rsquo;elle soit exécutée ou non dans une transaction. Pour exiger un respect de ces contraintes à l\u0026rsquo;issue de plusieurs transformations dans une transaction, il est possible de différer ces vérifications au moment du COMMIT.
Oracle et PostgreSQL proposent la même syntaxe SQL pour définir si une contrainte est différée de façon systématique :
ALTER TABLE ... CONSTRAINT ... [NOT] DEFERRABLE INITIALLY (IMMEDIATE | DEFERRED) Il est également possible de désactiver le contrôle au sein d\u0026rsquo;une transaction en cours à l\u0026rsquo;aide de l\u0026rsquo;instruction suivante, commune au deux systèmes :
SET CONSTRAINT (cons_name | ALL) DEFERRED; Enfin, il peut être nécessaire de définir au niveau d\u0026rsquo;une session que toutes les prochaines transactions soient différées par défaut. Dans ce cas, les commandes entre Oracle et PostgreSQL présentent des différences.
Avec Oracle, la syntaxe :
ALTER SESSION SET CONSTRAINTS = DEFERRED; ALTER SESSION SET CONSTRAINTS = IMMEDIATE; Devra être remplacée par :
SET default_transaction_deferrable = ON; SET default_transaction_deferrable = OFF; SET CONSTRAINTS SAVEPOINT # Les SAVEPOINT fonctionnent sans régression par rapport au SGBD Oracle. Les verrous acquis avant la mise en place d\u0026rsquo;un SAVEPOINT ne sont pas relâchés si un SAVEPOINT est relâché par un RELEASE SAVEPOINT ou un ROLLBACK TO SAVEPOINT
La documentation de PostgreSQL met néanmoins en garde contre la modification de lignes après le positionnement d\u0026rsquo;un SAVEPOINT alors que ces lignes ont été verrouillées par un SELECT ... FOR UPDATE avant le positionnement du SAVEPOINT. En effet, le verrou acquis par le SELECT ... FOR UPDATE peut être relâché au moment du ROLLBACK TO SAVEPOINT. La séquence suivante d\u0026rsquo;ordres SQL est donc à éviter :
BEGIN; SELECT * FROM ma_table WHERE cle = 1 FOR UPDATE; SAVEPOINT s; UPDATE ma_table SET ... WHERE cle = 1; ROLLBACK TO SAVEPOINT s; Références :
SAVEPOINT RELEASE SAVEPOINT ROLLBACK TO SAVEPOINT Gestion des verrous # Bien que PostgreSQL et Oracle partagent de nombreuses similitudes au niveau du verrouillage, il faut prendre en compte certaines différences subtiles.
Références :
Verrouillage explicite Verrouillage implicite # Les ordres DML acquièrent des verrous implicites. La différence notable entre Oracle et PostgreSQL concerne l\u0026rsquo;ordre SELECT : Oracle n\u0026rsquo;acquiert aucun verrou, tandis que PostgreSQL pose un verrou de type ACCESS SHARE. De ce fait, Oracle ne protège en aucun cas les lecteurs de modifications telles que la suppression d\u0026rsquo;une table. Une lecture peut être interrompue suite à un DROP TABLE concurrent. L\u0026rsquo;acquisition par PostgreSQL d\u0026rsquo;un verrou ACCESS SHARE pour la lecture protège de ce genre de problèmes.
Les ordres INSERT, UPDATE et DELETE verrouillent les lignes modifiées.
Références :
Dropping a table during SELECT, blog de Uwe Hesse Verrouillage explicite # SELECT FOR UPDATE
Les ordres SELECT FOR UPDATE peuvent nécessiter des adaptations. La syntaxe Oracle est en effet un peu plus riche que celle de PostgreSQL pour ce qui concerne cet ordre SQL.
Oracle propose une syntaxe WAIT et NOWAIT. PostgreSQL ne propose que la clause NOWAIT. La clause WAIT est implicite si NOWAIT n\u0026rsquo;est pas spécifié, il faudra donc la supprimer. La requête SELECT ... FOR UPDATE WAIT; devient SELECT ... FOR UPDATE;.
En l\u0026rsquo;état, la clause OF Oracle est incompatible avec le clause OF de PostgreSQL. Cette clause permet d\u0026rsquo;indiquer la table verrouillée pour une mise à jour ultérieure. Seulement, la clause OF d\u0026rsquo;Oracle désigne une colonne d\u0026rsquo;une table, tandis que la clause OF de PostgreSQL désigne une table. Références :
SELECT FOR UPDATE LOCK TABLE
La syntaxe de l\u0026rsquo;ordre LOCK TABLE d\u0026rsquo;Oracle est compatible avec celle de PostgreSQL pour les cas généraux. L\u0026rsquo;ensemble des modes de verrouillage proposés par Oracle existent tous dans PostgreSQL. On peut noter que PostgreSQL propose plus de type de verrous.
Tout comme pour l\u0026rsquo;ordre SELECT FOR UPDATE, Oracle propose une syntaxe WAIT et NOWAIT. PostgreSQL ne propose aussi que la clauseNOWAIT. La clause WAIT est implicite si NOWAIT n\u0026rsquo;est pas spécifié, il faudra donc la supprimer. La requête LOCK TABLE ... WAIT; devient LOCK TABLE ...;.
Les clauses PARTITION et SUBPARTITION ne peuvent cependant pas être reprises. Dans le cas de la mise en œuvre du partitionnement dans PostgreSQL, il faut désigner la table correspondant à la partition ciblée par l\u0026rsquo;acquisition d\u0026rsquo;un verrou.
Références :
LOCK TABLE `}),e.add({id:18,href:"/from-oracle-to-postgresql/fr/nous-contacter/",title:"Nous contacter",section:"Docs",content:` Nous contacter # Depuis 2005, Dalibo met à la disposition de ses clients son savoir-faire dans le domaine des bases de données et propose des services de conseil, de formation et de support aux entreprises et aux institutionnels.
Dalibo offre un large panel de services autour de PostgreSQL® et de ses logiciels satellites. Chaque intervention est axée sur 3 objectifs : sécurité des données, performance et qualité de service.
Pour vous faire accompagner dans votre projet de migration vers PostgreSQL, notre équipe commerciale sera ravi de vous répondre aux coordonnées suivantes :
🌐 https://dalibo.com 💌 contact@dalibo.com 🏠 43, rue du Faubourg Montmartre, 75009 Paris 📞 +33 1 83 64 61 88 Postgres, PostgreSQL et le logo éléphant de PostgreSQL (« Slonik ») sont des marques déposées et enregistrées par la PostgreSQL Community Association of Canada, et utilisées ici avec leur permission. `}),e.add({id:19,href:"/from-oracle-to-postgresql/fr/reprise-des-index/",title:"Reprise des index",section:"Portage du schéma",content:` Reprise des index # Pour les index, seule la forme BTREE correspond. Les autres types d\u0026rsquo;index d\u0026rsquo;Oracle ne sont pas implémentées mais PostgreSQL dispose lui-aussi d\u0026rsquo;autres types d\u0026rsquo;index. Quoiqu\u0026rsquo;il en soit, la plupart des index utilisés sont des index de type BTREE car c\u0026rsquo;est la méthode par défaut utilisée lors de la création d\u0026rsquo;un index.
Index sur chaînes de caractère # Lorsqu\u0026rsquo;un index sert à accélérer les recherches avec l\u0026rsquo;opérateur LIKE sur une colonne de type chaîne de caractères, il est nécessaire de le créer avec la classe d\u0026rsquo;opérateur varchar_pattern_ops pour une colonne de type VARCHAR, ou text_pattern_ops pour une colonne de type text, ou encore bpchar_pattern_ops pour une colonne de type CHAR. Ces opérateurs sont utiles lorsque les paramètres de localisation du serveur sont différents de C.
La classe d\u0026rsquo;opérateur adéquate est à ajouter après le nom de la colonne concernée dans l\u0026rsquo;ordre de création de l\u0026rsquo;index :
CREATE INDEX emp2_ename ON emp2 (ename varchar_pattern_ops); Références :
Classes et familles d\u0026rsquo;opérateurs Index Bitmap # Le cas d\u0026rsquo;utilisation des index bitmap, sous Oracle, est celui d\u0026rsquo;une colonne ayant très peu de valeurs différentes (faible cardinalité). Il crée donc un tableau de bits, chaque bit représentant la présence ou non d\u0026rsquo;une valeur dans un enregistrement de la table. Grossièrement, pour chaque enregistrement (ROWID), un bit est associé à la valeur indexée.
Le cas classique, pour le sexe, par exemple, on aura 2 bits, l\u0026rsquo;un pour homme, l\u0026rsquo;autre pour femme. Et on remplira un tableau de 2 bits, avec une entrée par ROWID potentiel de la table, ce qui fait donc un tableau à deux dimensions. L\u0026rsquo;avantage de cette méthode, c\u0026rsquo;est bien sûr que c\u0026rsquo;est extrêmement compact si la colonne a peu de valeurs différentes.
Il y a par contre plusieurs gros défauts :
tout ajout de colonne déclenche la réécriture de tout l\u0026rsquo;index. C\u0026rsquo;est long et surtout, ça verrouille l\u0026rsquo;index pendant ce temps. la concurrence est très faible: l\u0026rsquo;index étant tout petit, il est très probable que les sessions voudront mettre à jour les mêmes pages en même temps, au-delà de 8 valeurs différentes, les performances se dégradent très vite. PostgreSQL ne dispose pas de ces index. Il dispose par contre des index GIN, qui sont normalement utilisés surtout pour indexer des données non scalaires: tableaux, listes de mots, etc… L\u0026rsquo;article en référence détaille de manière assez détaillée le fonctionnement des index GIN.
Le principe de GIN est d\u0026rsquo;être un index inversé. Pour chaque valeur possible de l\u0026rsquo;attribut, on crée une liste des enregistrements vérifiant le prédicat (par exemple sexe='F'). Dans le cas d\u0026rsquo;un tableau, le même enregistrement peut se retrouver simultanément dans plusieurs listes (une liste différente par valeurs dans un tableau, par exemple).
Si on revient à notre cas H/F, on va avoir deux listes (ce qu\u0026rsquo;on appelle des posting lists, voir l\u0026rsquo;article en référence), l\u0026rsquo;une avec la liste des enregistrements où sexe='F', l\u0026rsquo;autre avec la liste des enregistrements où sexe='H'. Ces deux listes, depuis PostgreSQL 9.4, sont compressées, ce qui les rend très compactes. Pas autant qu\u0026rsquo;un bitmap, mais très compactes tout de même (et meilleure en concurrence d\u0026rsquo;accès).
La séquence suivante montre la différence de volumétrie entre un index Btree et un index GIN pour l\u0026rsquo;exemple évoqué :
-- Pour pouvoir indexer des scalaires, et pas uniquement des tableaux, avec gin CREATE extension btree_gin; CREATE TABLE t1 (name VARCHAR, sexe CHAR); -- 100 millions d\u0026#39;enregistrements, le nom est un numéro, et le sexe est 50/50 INSERT INTO t1 SELECT i, CASE WHEN i%2 = 0 THEN \u0026#39;F\u0026#39; ELSE \u0026#39;M\u0026#39; END FROM generate_series(1,100000000) g(i); CREATE INDEX idx_sexe_gin ON t1 USING gin (sexe); SELECT pg_size_pretty(pg_table_size(\u0026#39;t1\u0026#39;)); -- pg_size_pretty -- ---------------- -- 4223 MB SELECT pg_size_pretty(pg_table_size(\u0026#39;idx_sexe_gin\u0026#39;)); -- pg_size_pretty -- ---------------- -- 102 MB SELECT pg_size_pretty(pg_table_size(\u0026#39;idx_sexe_btree\u0026#39;)); -- pg_size_pretty -- ---------------- -- 2142 MB Les index GIN ne sont donc pas aussi compact que des index bitmaps. Par contre, d\u0026rsquo;un point de vue de l\u0026rsquo;accès concurrentiel, ils sont supérieurs (organisés de façon similaires à des BTrees). C\u0026rsquo;est donc un compromis un peu différent, mais ils permettent de répondre à la même problématique.
De même que les index BTree, les index GIN peuvent être utilisés pour réaliser des opérations de bitmap, afin d\u0026rsquo;utiliser plusieurs index simultanément pour restreindre le volume de données à consulter.
Références :
GIN – Just A Kind Of Index, par Hans-Juergen Schoenig. Index inverse # Les index inverses (ou reverse) permettent d\u0026rsquo;accélérer des recherches de type LIKE '%chaine', opérations qui ne bénéficient pas ordinairement de la présence d\u0026rsquo;un index. L\u0026rsquo;index inverse n\u0026rsquo;existe pas directement dans PostgreSQL mais il est possible d\u0026rsquo;utiliser l\u0026rsquo;extension pg_trgm et un index KKN-GiST pour émuler un index inverse et même le surpasser. En effet, cette extension offre également la possibilité d\u0026rsquo;utiliser un index pour les recherches telles que LIKE '%chaine%' ou même LIKE '%chaine%chaine%'. Il faut toutefois garder à l\u0026rsquo;esprit que la mise à jour d\u0026rsquo;un index GiST est plus coûteuse que la mise à jour d\u0026rsquo;un index BTREE.
L\u0026rsquo;extension pg_trgm, bien qu\u0026rsquo;elle ne soit pas incluse dans le cœur de PostgreSQL, est distribuée avec PostgreSQL (paquet postgresql-contrib) et est maintenue par les développeurs de PostgreSQL.
Ce type d\u0026rsquo;index n\u0026rsquo;est pas créé automatiquement par Ora2Pg, il nécessite une intervention manuelle.
CREATE EXTENSION pg_trgm; CREATE INDEX idx_emp_ename_trgm ON emp USING gist (ename gist_trgm_ops); --or CREATE INDEX idx_emp_ename_trgm ON emp USING gin (ename gin_trgm_ops); Le plan d\u0026rsquo;exécution d\u0026rsquo;une requête SELECT montre bien l\u0026rsquo;utilisation de l\u0026rsquo;index idx_emp_ename_trgm :
EXPLAIN SELECT * FROM emp WHERE ename LIKE \u0026#39;%IN%\u0026#39;; -- QUERY PLAN -- ---------------------------------------------------------------------------------------- -- Bitmap Heap Scan on emp (cost=1442.95..3522.23 rows=32742 width=20) -- Recheck Cond: ((ename)::text ~~ \u0026#39;%IN%\u0026#39;::text) -- -\u0026gt; Bitmap Index Scan on idx_emp_ename_trgm (cost=0.00..1434.77 rows=32742 width=0) -- Index Cond: ((ename)::text ~~ \u0026#39;%IN%\u0026#39;::text) Ces index peuvent également être employés pour des recherches insensibles à la casse, comme ILIKE.
Références :
Indexation des K plus proches voisins, Quoi de neuf dans PostgreSQL 9.1 ? Extension pg_trgm Création d\u0026rsquo;index sans blocage # PostgreSQL permet de créer des index sans bloquer les accès concurrents, grâce à l\u0026rsquo;ordre CREATE INDEX CONCURRENTLY. Cet ordre présente néanmoins le risque de laisser l\u0026rsquo;index invalide à l\u0026rsquo;issue de sa création. Cela arrive si l\u0026rsquo;index ne peut pas être construit, s\u0026rsquo;il s\u0026rsquo;agit par exemple d\u0026rsquo;un index UNIQUE, et que la contrainte d\u0026rsquo;unicité n\u0026rsquo;est pas respectée.
De la même manière, il est possible de recréer un index sans bloquer les accès concurrents, à l\u0026rsquo;aide de l\u0026rsquo;ordre REINDEX CONCURRENTLY. Comme pour la création, il peut arriver que l\u0026rsquo;index soit laissé invalide.
Références :
CREATE INDEX REINDEX `}),e.add({id:20,href:"/from-oracle-to-postgresql/fr/reprise-des-partitions/",title:"Reprise des partitions",section:"Portage du schéma",content:` Reprise des partitions # PostgreSQL dispose d\u0026rsquo;un partitionnement déclaratif depuis la version 10, qui ne cesse de s\u0026rsquo;améliorer de version majeure en version majeure. Le type du partitionnement est décisif au moment de la définition du modèle, car il est très coûteux de le changer au moment de la vie des données. Contrairement à Oracle, la table partitionnée doit être créée séparément avant que les partitions puissent être définies.
Partitionnement par liste # La définition suivante d\u0026rsquo;une table partitionnée Oracle :
CREATE TABLE t1 (c1 integer, c2 varchar2(100)) PARTITION BY LIST (c1) ( PARTITION t1_a VALUES (1, 2, 3), PARTITION t1_b VALUES (4, 5), PARTITION t1_default VALUES (DEFAULT) ); Sera reprise de cette façon avec PostgreSQL :
CREATE TABLE t1(c1 integer, c2 varchar(100)) PARTITION BY LIST (c1) ; CREATE TABLE t1_a PARTITION OF t1 FOR VALUES IN (1, 2, 3); CREATE TABLE t1_b PARTITION OF t1 FOR VALUES IN (4, 5); CREATE TABLE t1_default PARTITION of t1 DEFAULT; Partitionnement par intervalles # Oracle permet la déclaration d\u0026rsquo;intervalles de valeurs à l\u0026rsquo;aide de la clause LESS THAN afin de joindre la borne inférieure d\u0026rsquo;une partition avec la borne supérieure d\u0026rsquo;une autre partition. Les valeurs sont donc strictement comprises entre -∞ et la plus haute borne supérieure.
CREATE TABLE t2 (c1 integer, c2 varchar2(100)) PARTITION BY RANGE (c1) ( PARTITION t2_a VALUES LESS THAN (0), PARTITION t2_b VALUES LESS THAN (100), PARTITION t2_c VALUES LESS THAN (MAXVALUE) ); Les deux bornes de l\u0026rsquo;intervalle d\u0026rsquo;une partition doivent être précisées lors de la déclaration avec PostgreSQL, la borne supérieure étant exclue de l\u0026rsquo;intervalle. La table partitionnée sera donc traduite de cette façon :
CREATE TABLE t2 (c1 integer, c2 varchar(100)) PARTITION BY RANGE (c1); CREATE TABLE t2_a PARTITION OF t2 FOR VALUES FROM (MINVALUE) TO (0); CREATE TABLE t2_b PARTITION OF t2 FOR VALUES FROM (0) TO (100); CREATE TABLE t2_c PARTITION OF t2 FOR VALUES FROM (100) TO (MAXVALUE); Partitionnement par intervalles automatique # Oracle propose de créer automatiquement les partitions à l\u0026rsquo;aide de la clause INTERVAL et d\u0026rsquo;un litéral représentant un intervalle DAY TO SECOND ou YEAR TO MONTH. Dans l\u0026rsquo;exemple ci-dessous, seule la première partition pivot est définie ; toutes les données insérées provoqueront la création d\u0026rsquo;une partition lorsque la valeur de la clé de partitionnement se trouve au-delà de la borne supérieure de la partition pivot.
CREATE TABLE t2_auto (c1 number(6), c2 date) PARTITION BY RANGE (c2) INTERVAL (NUMTOYMINTERVAL(1, \u0026#39;MONTH\u0026#39;)) ( PARTITION t2_part VALUES LESS THAN (TO_DATE(\u0026#39;01-JAN-2020\u0026#39;,\u0026#39;dd-MON-yyyy\u0026#39;)) ); INSERT INTO t2_auto VALUES (1, TO_DATE(\u0026#39;01-DEC-2000\u0026#39;,\u0026#39;dd-MON-yyyy\u0026#39;)); INSERT INTO t2_auto VALUES (2, TO_DATE(\u0026#39;01-OCT-2022\u0026#39;,\u0026#39;dd-MON-yyyy\u0026#39;)); INSERT INTO t2_auto VALUES (3, TO_DATE(\u0026#39;01-DEC-2022\u0026#39;,\u0026#39;dd-MON-yyyy\u0026#39;)); La vue USER_TAB_PARTITIONS présente les partitions, dont deux nouvelles qui portent un nom généré par le moteur.
TABLE_NAME PARTITION_NAME HIGH_VALUE T2_AUTO T2_PART TO_DATE(\u0026lsquo;2020-01-01\u0026rsquo;, \u0026lsquo;SYYYY-MM-DD\u0026rsquo;) T2_AUTO SYS_P472681 TO_DATE(\u0026lsquo;2021-11-01\u0026rsquo;, \u0026lsquo;SYYYY-MM-DD\u0026rsquo;) T2_AUTO SYS_P472682 TO_DATE(\u0026lsquo;2023-01-01\u0026rsquo;, \u0026lsquo;SYYYY-MM-DD\u0026rsquo;) Cette fonctionnalité de création automatique des partitions n\u0026rsquo;est pas disponible nativement avec PostgreSQL. Il est cependant possible de se rapprocher du comportement présenté ci-dessus à l\u0026rsquo;aide du projet pg_partman. Cette extension repose sur des tables de configuration et d\u0026rsquo;une routine de maintenance afin de détecter les tables partitionnées nécessitant de nouvelles partitions.
Contrairement à Oracle, toute nouvelle ligne en dehors d\u0026rsquo;une des bornes existantes est insérée dans la partition par défaut. La routine de maintenance se charge de déplacer les données vers les partitions attribuées de façon asynchrone.
Prenons l\u0026rsquo;exemple de la table t2_auto qui peut être transformée de la façon suivante. L\u0026rsquo;option premake permet d\u0026rsquo;anticiper la création de n partitions à partir du prochain intervalle au moment de l\u0026rsquo;exécution de la méthode.
CREATE TABLE t2_auto (c1 integer, c2 date) PARTITION BY RANGE (c2); CREATE SCHEMA partman; CREATE EXTENSION pg_partman WITH SCHEMA partman; SELECT partman.create_parent( p_parent_table =\u0026gt; \u0026#39;public.t2_auto\u0026#39;, p_control =\u0026gt; \u0026#39;c2\u0026#39;, p_type =\u0026gt; \u0026#39;native\u0026#39;, p_interval =\u0026gt; \u0026#39;monthly\u0026#39;, p_premake =\u0026gt; 1 ); La requête suivante montre la distribution de trois lignes au sein des partitions :
INSERT INTO t2_auto VALUES (1, \u0026#39;2000-12-01\u0026#39;); INSERT INTO t2_auto VALUES (2, \u0026#39;2022-10-01\u0026#39;); INSERT INTO t2_auto VALUES (3, \u0026#39;2022-12-01\u0026#39;); SELECT tableoid::regclass, * from t2_auto; -- tableoid | c1 | c2 -- -----------------+----+------------ -- t2_auto_p2022_10 | 2 | 2022-10-01 -- t2_auto_default | 1 | 2000-12-01 -- t2_auto_default | 3 | 2022-12-01 L\u0026rsquo;outil propose une série de méthodes de maintenance pour ajouter de nouvelles partitions et redistribuer les lignes présentes dans la table par défaut. Ces opérations doivent être planifiées par un orchestrateur externe (cron, pg_cron, etc.) ou à l\u0026rsquo;aide du processus d\u0026rsquo;arrière-plan fourni avec l\u0026rsquo;extension. Cette dernière solution nécessite de positionner la valeur pg_partman_bgw au paramètre shared_preload_libraries et de redémarrer l\u0026rsquo;instance.
-- Surveille les données insérées dans les tables parents et la -- table par défaut SELECT * FROM partman.check_default(); -- Déplace les données des tables parents ou de la table par défaut -- vers les enfants appropriés. SELECT * FROM partman.partition_data_time(p_parent_table =\u0026gt; \u0026#39;public.t2_auto\u0026#39;); -- Crée automatiquement des tables enfants pour les partitions gérées -- par pg_partman CALL partman.run_maintenance_proc(); Les données sont à présent dans les bonnes partitions.
SELECT tableoid::regclass, * from t2_auto; -- tableoid | c1 | c2 -- -----------------+----+------------ -- t2_auto_p2000_12 | 1 | 2000-12-01 -- t2_auto_p2022_10 | 2 | 2022-10-01 -- t2_auto_p2022_12 | 3 | 2022-12-01 Partitionnement par hâchage # Pour répartir équitablement les données entre un nombre fini de partitions, Oracle et PostgreSQL proposent le même fonctionnement de partitionnement par hâchage.
La table partitionnée suivante avec Oracle :
CREATE TABLE t3 (c1 integer, c2 varchar2(100)) PARTITION BY HASH (c1) ( PARTITION t3_a, PARTITION t3_b, PARTITION t3_c ); Sera convertie de la sorte avec PostgreSQL :
CREATE TABLE t3 (c1 integer, c2 varchar(100)) PARTITION BY HASH (c1); CREATE TABLE t3_a PARTITION OF t3 FOR VALUES WITH (modulus 3, remainder 0); CREATE TABLE t3_b PARTITION OF t3 FOR VALUES WITH (modulus 3, remainder 1); CREATE TABLE t3_c PARTITION OF t3 FOR VALUES WITH (modulus 3, remainder 2); Lorsqu\u0026rsquo;il est nécessaire d\u0026rsquo;ajouter une ou plusieurs partitions à une table partitionnée, notamment pour répartir à nouveau le volume de lignes, Oracle choisit lui-même une partition selon l\u0026rsquo;algorithme de hâchage pour diviser le contenu de la partition en deux afin de redistribuer l\u0026rsquo;une des moitiés sur la nouvelle partition.
Avec Oracle, l\u0026rsquo;ordre de maintenance suivant réalise les opérations de façon transparente :
ALTER TABLE t3 ADD PARTITION t3_d; Avec PostgreSQL, il revient à l\u0026rsquo;administrateur de sélectionner la partition source en élargissant les options modulus et remainder pour répartir les deux (ou plus) sous-ensembles de données, dont chaque moitié sera déplacée dans les nouvelles partitions. Cette opération nécessite de poser un verrou dans une transaction le temps de la copie vers les deux nouvelles partitions :
BEGIN; -- Remplacement d\u0026#39;une partition par deux sous-ensembles ALTER TABLE t3 DETACH PARTITION t3_c; CREATE TABLE t3_c_0 PARTITION OF t3 FOR VALUES WITH (modulus 6, remainder 0); CREATE TABLE t3_c_3 PARTITION OF t3 FOR VALUES WITH (modulus 6, remainder 3); -- Déplacement des lignes INSERT INTO t3 SELECT * FROM t3_c; DROP TABLE t3_c; COMMIT; Partitionnement composite # Les précédentes méthodes peuvent être couplées pour répondre à des besoins de partitionnement plus précis, sur plusieurs niveaux de clés de partitionnement. Prenons la table suivante avec Oracle qui présente des partitions par liste et des sous-partitions par intervalles :
CREATE TABLE t4 (c1 char(1), c2 date) PARTITION BY LIST (c1) SUBPARTITION BY RANGE (c2) ( PARTITION t4_a VALUES (\u0026#39;A\u0026#39;) ( SUBPARTITION t4_a_2020 VALUES LESS THAN (TO_DATE(\u0026#39;01-JAN-2021\u0026#39;,\u0026#39;dd-MON-yyyy\u0026#39;)), SUBPARTITION t4_a_2021 VALUES LESS THAN (TO_DATE(\u0026#39;01-JAN-2022\u0026#39;,\u0026#39;dd-MON-yyyy\u0026#39;)), SUBPARTITION t4_a_2022 VALUES LESS THAN (TO_DATE(\u0026#39;01-JAN-2023\u0026#39;,\u0026#39;dd-MON-yyyy\u0026#39;)) ), PARTITION t4_b VALUES (\u0026#39;B\u0026#39;) ( SUBPARTITION t4_b_2020 VALUES LESS THAN (TO_DATE(\u0026#39;01-JAN-2021\u0026#39;,\u0026#39;dd-MON-yyyy\u0026#39;)), SUBPARTITION t4_b_2021 VALUES LESS THAN (TO_DATE(\u0026#39;01-JAN-2022\u0026#39;,\u0026#39;dd-MON-yyyy\u0026#39;)), SUBPARTITION t4_b_2022 VALUES LESS THAN (TO_DATE(\u0026#39;01-JAN-2023\u0026#39;,\u0026#39;dd-MON-yyyy\u0026#39;)) ) ); Avec PostgreSQL, il sera suffisant de créer des tables partitionnées rattachées à d\u0026rsquo;autres tables partitionnées. Les partitions définissent le niveau de profondeur final. L\u0026rsquo;exemple précédent sera réécrit de cette manière :
CREATE TABLE t4 (c1 char(1), c2 date) PARTITION BY LIST (c1); CREATE TABLE t4_a PARTITION OF t4 FOR VALUES IN (\u0026#39;A\u0026#39;) PARTITION BY RANGE (c2); CREATE TABLE t4_a_2020 PARTITION OF t4_a FOR VALUES FROM (MINVALUE) TO (\u0026#39;2021-01-01\u0026#39;); CREATE TABLE t4_a_2021 PARTITION OF t4_a FOR VALUES FROM (\u0026#39;2021-01-01\u0026#39;) TO (\u0026#39;2022-01-01\u0026#39;); CREATE TABLE t4_a_2022 PARTITION OF t4_a FOR VALUES FROM (\u0026#39;2022-01-01\u0026#39;) TO (\u0026#39;2023-01-01\u0026#39;); CREATE TABLE t4_b PARTITION OF t4 FOR VALUES IN (\u0026#39;B\u0026#39;) PARTITION BY RANGE (c2); CREATE TABLE t4_b_2020 PARTITION OF t4_b FOR VALUES FROM (MINVALUE) TO (\u0026#39;2021-01-01\u0026#39;); CREATE TABLE t4_b_2021 PARTITION OF t4_b FOR VALUES FROM (\u0026#39;2021-01-01\u0026#39;) TO (\u0026#39;2022-01-01\u0026#39;); CREATE TABLE t4_b_2022 PARTITION OF t4_b FOR VALUES FROM (\u0026#39;2022-01-01\u0026#39;) TO (\u0026#39;2023-01-01\u0026#39;); Le partitionnement permet de répondre à plusieurs problématiques. L\u0026rsquo;une d\u0026rsquo;entre elle concerne les performances, si le partitionnement est bien conçu et les requêtes écrites de façon à tirer partie du partitionnement, alors PostgreSQL ne lira qu\u0026rsquo;une ou quelques partitions et non pas la totalité des partitions.
Une autre problématique adressée concerne la maintenance. Le partitionnement permet en effet de simplifier les opérations de suppressions de données. Par exemple, la suppression des données relatives à une année se résumera à la simple suppression d\u0026rsquo;une table si la table est partitionnée sur l\u0026rsquo;année. Les opérations de maintenance (VACUUM, ANALYZE) sont également bien plus efficace.
Cependant, le partitionnement déclaratif avec PostgreSQL peut souffrir d\u0026rsquo;insuffisances fonctionnelles par rapport aux avancées que présente Oracle. Par exemple, les contraintes de clés étrangères définies avec des actions telles que ON DELETE ... CASCADE peuvent avoir des comportements surprenants sur des tables partitionnées avant la version 15, où le déplacement d\u0026rsquo;une ligne entre deux partitions déclenche la suppression en cascade des lignes de la clé étrangère.
Références :
Partitionnement Cas d\u0026rsquo;usages du partitionnement natif dans PostgreSQL Projet pg_partman Release 15: Enforce foreign key correctly during cross-partition updates `}),e.add({id:21,href:"/from-oracle-to-postgresql/fr/specificites-pl-sql/",title:"Spécificités PL/SQL",section:"Portage du code PL/SQL vers PL/pgSQL",content:` Spécificités PL/SQL # Transactions autonomes # On retrouve souvent des PRAGMA associés aux transactions autonomes en PL/SQL. Cette dernière notion n\u0026rsquo;existe pas dans PostgreSQL.
Il est possible d\u0026rsquo;émuler les transactions autonomes par le biais d\u0026rsquo;un dblink, mais c\u0026rsquo;est une solution particulièrement contre-performante et consommatrice de ressources. En effet, l\u0026rsquo;utilisation d\u0026rsquo;un dblink va entraîner une nouvelle connexion à la base de données. Le coût d\u0026rsquo;une nouvelle connexion n\u0026rsquo;est pas neutre (vérification des droits, fork d\u0026rsquo;un nouveau processus, etc.). Cette nouvelle connexion nécessitera de bien dimensionner le paramètre max_connections et consommera de la mémoire et du temps CPU supplémentaire.
Le code PL/SQL Oracle suivant reprend la déclaration d\u0026rsquo;une procédure autonome :
CREATE PROCEDURE LOG_ACTION (username VARCHAR2, msg VARCHAR2) IS PRAGMA AUTONOMOUS_TRANSACTION; BEGIN INSERT INTO table_tracking VALUES (username, msg); COMMIT; END log_action; Une réécriture possible avec un dblink implique de renseigner les informations de connexion à l\u0026rsquo;instance locale PostgreSQL :
CREATE EXTENSION dblink; CREATE OR REPLACE FUNCTION log_action(username TEXT, msg TEXT) RETURNS void AS $$ BEGIN perform dblink_connect(\u0026#39;pragma\u0026#39;, format( \u0026#39;dbname=%s user=test password=test\u0026#39;, current_database() )); perform dblink_exec(\u0026#39;pragma\u0026#39;, format( \u0026#39;insert into table_tracking values (%s, %s);\u0026#39;, username, msg )); perform dblink_exec(\u0026#39;pragma\u0026#39;,\u0026#39;commit;\u0026#39;); perform dblink_disconnect(\u0026#39;pragma\u0026#39;); END; $$ LANGUAGE plpgsql; Une autre alternative, apparue en version 9.5 avec les background workers, consiste à s\u0026rsquo;appuyer sur l\u0026rsquo;extension pg_background pour déporter l\u0026rsquo;exécution d\u0026rsquo;une procédure dans une nouvelle transaction à l\u0026rsquo;aide d\u0026rsquo;une procédure wrapper et la méthode pg_background_launch de l\u0026rsquo;extension.
Une autre réécriture du code précédent ressemblerait à ceci avec pg_background, avec la création d\u0026rsquo;une procédure appelante :
-- Créer une fonction que nous déclencherons « à distance » CREATE OR REPLACE FUNCTION log_action_atx(username TEXT, msg TEXT) RETURNS void AS $$ BEGIN INSERT INTO table_tracking VALUES (username, msg); END; $$ LANGUAGE plpgsql; -- Créer la fonction principale, chargée d\u0026#39;appeler la fonction distante CREATE OR REPLACE FUNCTION log_action(username TEXT, msg TEXT) RETURNS void AS $$ DECLARE v_query text; BEGIN v_query := format( \u0026#39;SELECT true FROM log_action_atx (%s, %s)\u0026#39;, quote_nullable(username), quote_nullable(msg) ); PERFORM pg_background_result( pg_background_launch(v_query) ); END; $body$ LANGUAGE plpgsql SECURITY DEFINER; La méthode log_action se comporte exactement comme si elle exécutait une instruction dans une transaction autonome.
Références :
Support des transactions autonomes dans PostgreSQL Les collections VARRAY # Les collections VARRAY des packages Oracle sont reprises sous la forme d\u0026rsquo;un type tableau, de n éléments. Leur définition est reprise par Ora2Pg, mais elles nécessitent généralement une réécriture du code l\u0026rsquo;utilisant.
Lorsque la VARRAY est un simple tableau d\u0026rsquo;un type donné, la reprise nécessite moins d\u0026rsquo;intervention que lorsque la VARRAY est du type %ROWTYPE. Dans ce cas, la reprise est bien plus difficile et nécessite une réécriture forte.
Le code suivant :
DECLARE TYPE Calendar IS VARRAY(366) OF DATE; sera transposé de la façon suivante :
CREATE TYPE calendar AS (date[366]); En revanche, le code suivant sera transposé par Ora2Pg mais inutilisable sans modifications :
TYPE t_tab_emp IS VARRAY (1000) OF emp%ROWTYPE; ... tab_emp t_tab_emp; -- déclaration de la variable Les tableaux associatifs et tables imbriquées # Les collections TABLE OF sont utilisées généralement pour déclarer des fonctions qui retournent un ensemble de données. De ce fait, les types TABLE OF peuvent être supprimés et remplacés par un RETURNS TABLE, voire un RETURNS SETOF type_de_donnees pour les types de données simples. Se référer à la section Attribut PIPELINED et instruction PIPE ROW de la partie « Portage des procédures et fonctions » pour un exemple où la collection TABLE OF est inutile.
Quoi qu\u0026rsquo;il en soit, Ora2Pg traduit ce type de données par un tableau du type de données associé, nécessitant probablement une révision du code porté.
Ainsi, la déclaration suivante :
CREATE TYPE information IS TABLE OF VARCHAR2(255); sera transposée en tableau de type VARCHAR(255) par Ora2Pg :
CREATE TYPE information AS VARCHAR(255)[]; Cependant, la clause NUMBER INDEX n\u0026rsquo;a pas d\u0026rsquo;équivalent. Par exemple, la déclaration suivante :
TYPE t_liste_qlf_id IS TABLE OF NUMBER INDEX BY VARCHAR2(5); ne peut être portée directement. Il est possible d\u0026rsquo;utiliser le module contrib hstore pour émuler cette fonctionnalité.
Références :
Extension hstore `}),e.add({id:22,href:"/from-oracle-to-postgresql/fr/packages-proprietaires/",title:"Packages propriétaires",section:"Portage du code PL/SQL vers PL/pgSQL",content:" Packages propriétaires # Les paquets de fonctions et de procédures fournis par Oracle, n\u0026rsquo;ont pas ou peu d\u0026rsquo;équivalents dans PostgreSQL. Il est possible de chercher à les réécrire entièrement ou bien de s\u0026rsquo;appuyer sur des contributions libres pour obtenir un comportement proche de ceux proposés par Oracle.\nAppels au package DBMS_OUTPUT # Les appels aux fonctions de sortie Oracle DBMS_OUTPUT.put_line, DBMS_OUTPUT.put et DBMS_OUTPUT.new_line sont remplacés par RAISE NOTICE par Ora2Pg.\nAinsi, la procédure Oracle suivante :\nCREATE PROCEDURE tousLesAuteurs IS TYPE my_array IS varray(100) OF VARCHAR(25); temp_arr my_array; BEGIN ... DBMS_OUTPUT.put_line(i || \u0026#39;) nom: \u0026#39; || temp_arr..(i)); ... END tousLesAuteurs; sera traduite de la façon suivante pour PostgreSQL :\nCREATE FUNCTION tousLesAuteurs() RETURNS VOID AS $$ DECLARE temp_arr VARCHAR(25)[]; BEGIN ... RAISE NOTICE \u0026#39;% ) nom: %\u0026#39;, i, temp_arr..(i); ... END; $$ LANGUAGE plpgsql; Appels aux packages DBMS_XXX # Certains sont implémentés dans la librairie Orafce, comme :\nUTL_FILE DBMS_PIPE DBMS_OUTPUT DBMS_ALERT Certaines fonctionnalités avancées de ces modules Oracle peuvent aussi être intégrées dans des outils externes à PostgreSQL ou des extensions :\nOracle Advanced Queuing =\u0026gt; voir PgQ Oracle Jobs scheduler =\u0026gt; voir pgAgent / pg_timetable / pg_cron Et certaines autres peuvent très facilement être écrites avec un language procédural étendu comme Perl. Par exemple, si vous utilisiez le module UTL_SMTP pour envoyer des emails depuis votre base de données, le code suivant fera très simplement la même chose :\nCREATE OR REPLACE FUNCTION send_email(name, INET, TEXT, TEXT, TEXT) RETURNS INTEGER AS $body$ use Net::SMTP; my ($Db, $Ip, $sendTo, $Subject, $Message) = @_; my $smtp = Net::SMTP-\u0026gt;new(\u0026#34;mailhost\u0026#34;, Timeout =\u0026gt; 60); $smtp-\u0026gt;mail(\u0026#34;$Db\\@$Ip\u0026#34;); $smtp-\u0026gt;recipient($sendTo); $smtp-\u0026gt;data(); $smtp-\u0026gt;datasend(\u0026#34;To: $sendTo\\n\u0026#34;); $smtp-\u0026gt;datasend(\u0026#34;Subject: $Subject\\n\u0026#34;); $smtp-\u0026gt;datasend(\u0026#34;Content-Type: text/plain;\\n\\n\u0026#34;); $smtp-\u0026gt;datasend(\u0026#34;$Message\\n\u0026#34;); $smtp-\u0026gt;dataend(); $smtp-\u0026gt;quit(); return 1; $body$ language \u0026#39;plperlu\u0026#39;; SELECT send_email( current_database(), inet_server_addr(), \u0026#39;dba@dom.com\u0026#39;, \u0026#39;test pg_utl_smtp\u0026#39;, \u0026#39;Just a test\u0026#39; ); Références :\nPGQ Tutorial "})})()