<!doctype html><html lang=en dir=ltr><head><meta name=generator content="Hugo 0.106.0"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Porting SQL queries # DML statements compatibility # Most DML statements are compatible between Oracle and PostgreSQL. Note though that the MERGE statement doesn&rsquo;t exist yet in PostgreSQL. Some restrictions exist for some window functions and recursive Common Table Expressions (CTE)."><meta name=theme-color content="#FFFFFF"><meta property="og:title" content="Porting SQL queries"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://dalibo.github.io/from-oracle-to-postgresql/porting-sql-queries/"><meta property="og:site_name" content="From Oracle to PostgreSQL"><title>Porting SQL queries</title><link rel=manifest href=/from-oracle-to-postgresql/manifest.json><link rel=icon href=/from-oracle-to-postgresql/favicon.png type=image/x-icon><link rel=alternate hreflang=fr href=https://dalibo.github.io/from-oracle-to-postgresql/fr/portage-des-requetes-sql/ title="Portage des requêtes SQL"><link rel=stylesheet href=/from-oracle-to-postgresql/book.min.a0b1bf814d7fc28217ec0eea7c47371480fb4f325cec9eb1ae1aa1097d715ec7.css integrity="sha256-oLG/gU1/woIX7A7qfEc3FID7TzJc7J6xrhqhCX1xXsc="><script defer src=/from-oracle-to-postgresql/en.search.min.674c317d6de3ea1750637aec6a0cb86b72ba9ce8ba6edad9fb6f03d22d486135.js integrity="sha256-Z0wxfW3j6hdQY3rsagy4a3K6nOi6btrZ+28D0i1IYTU="></script>
<script defer src=/from-oracle-to-postgresql/sw.min.83ed3a56e2fac2ed3c3c3e1a69afc266f54bc9e92078450a47292a4db2ee86f1.js integrity="sha256-g+06VuL6wu08PD4aaa/CZvVLyekgeEUKRykqTbLuhvE="></script>
<link rel=alternate type=application/rss+xml href=https://dalibo.github.io/from-oracle-to-postgresql/porting-sql-queries/index.xml title="From Oracle to PostgreSQL"></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a href=/from-oracle-to-postgresql><img src=/from-oracle-to-postgresql/images/logo.png alt=Logo><span>From Oracle to PostgreSQL</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=https://dalibo.github.io/from-oracle-to-postgresql/general-differences-between-oracle-and-postgresql/>General differences</a><ul></ul></li><li><input type=checkbox id=section-88c4d5ca464ed2de3d87c4f315803bbb class=toggle>
<label for=section-88c4d5ca464ed2de3d87c4f315803bbb class="flex justify-between"><a href=https://dalibo.github.io/from-oracle-to-postgresql/porting-the-database-schema-to-postgresql/>Porting database objects</a></label><ul><li><a href=https://dalibo.github.io/from-oracle-to-postgresql/datatypes/>Datatypes</a></li><li><a href=https://dalibo.github.io/from-oracle-to-postgresql/table-migration/>Table migration</a></li><li><a href=https://dalibo.github.io/from-oracle-to-postgresql/views-migration/>Views migration</a></li><li><a href=https://dalibo.github.io/from-oracle-to-postgresql/sequences-migration/>Sequences migration</a></li><li><a href=https://dalibo.github.io/from-oracle-to-postgresql/index-migration/>Index migration</a></li><li><a href=https://dalibo.github.io/from-oracle-to-postgresql/partitioning/>Partitioning</a></li></ul></li><li><input type=checkbox id=section-b7e37e1862e6db598e5e41747363d74a class=toggle checked>
<label for=section-b7e37e1862e6db598e5e41747363d74a class="flex justify-between"><a href=https://dalibo.github.io/from-oracle-to-postgresql/porting-sql-queries/ class=active>Porting SQL queries</a></label><ul><li><a href=https://dalibo.github.io/from-oracle-to-postgresql/specificities-on-data-types/>Specificities on Data types</a></li><li><a href=https://dalibo.github.io/from-oracle-to-postgresql/joins/>Joins</a></li><li><a href=https://dalibo.github.io/from-oracle-to-postgresql/conditional-expressions/>Conditional expressions</a></li><li><a href=https://dalibo.github.io/from-oracle-to-postgresql/hierarchical-querying/>Hierarchical querying</a></li><li><a href=https://dalibo.github.io/from-oracle-to-postgresql/transaction-management/>Transaction management</a></li></ul></li><li><input type=checkbox id=section-cfaa4d420be7e860c2f111a313f9a252 class=toggle>
<label for=section-cfaa4d420be7e860c2f111a313f9a252 class="flex justify-between"><a href=https://dalibo.github.io/from-oracle-to-postgresql/pl-sql-to-pl-pgsql-porting/>PL/SQL to PL/pgSQL porting</a></label><ul><li><a href=https://dalibo.github.io/from-oracle-to-postgresql/porting-procedures-and-functions/>Porting procedures and functions</a></li><li><a href=https://dalibo.github.io/from-oracle-to-postgresql/triggers-conversion/>Triggers conversion</a></li><li><a href=https://dalibo.github.io/from-oracle-to-postgresql/control-structures/>Control structures</a></li><li><a href=https://dalibo.github.io/from-oracle-to-postgresql/pl-sql-code-conversion/>PL/SQL code conversion</a></li><li><a href=https://dalibo.github.io/from-oracle-to-postgresql/cursors/>Cursors</a></li><li><a href=https://dalibo.github.io/from-oracle-to-postgresql/pl-sql-specificities/>PL/SQL specificities</a></li><li><a href=https://dalibo.github.io/from-oracle-to-postgresql/oracles-packages/>Oracle's packages</a></li></ul></li><li><a href=https://dalibo.github.io/from-oracle-to-postgresql/contact-us/>Contact us</a><ul></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/from-oracle-to-postgresql/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Porting SQL queries</strong>
<label for=toc-control><img src=/from-oracle-to-postgresql/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#porting-sql-queries>Porting SQL queries</a><ul><li><a href=#dml-statements-compatibility>DML statements compatibility</a></li><li><a href=#subquery-aliases>Subquery aliases</a></li><li><a href=#implicit-conversions>Implicit conversions</a></li><li><a href=#having-and-group-by-clauses>HAVING and GROUP BY clauses</a></li><li><a href=#rowid>ROWID</a></li><li><a href=#minus-operator-conversion>Minus operator conversion</a></li><li><a href=#window-functions>Window Functions</a></li><li><a href=#recursive-cte>Recursive CTE</a></li><li><a href=#merge>MERGE</a></li><li><a href=#hints-management>Hints management</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=porting-sql-queries>Porting SQL queries
<a class=anchor href=#porting-sql-queries>#</a></h1><h2 id=dml-statements-compatibility>DML statements compatibility
<a class=anchor href=#dml-statements-compatibility>#</a></h2><p>Most DML statements are compatible between Oracle and PostgreSQL. Note though
that the <code>MERGE</code> statement doesn&rsquo;t exist yet in PostgreSQL. Some restrictions
exist for some window functions and recursive Common Table Expressions (CTE).</p><h2 id=subquery-aliases>Subquery aliases
<a class=anchor href=#subquery-aliases>#</a></h2><p>Oracle does not handle error messages while subqueries are unaliased unlike
PostgreSQL. For instance, this query need to be rewritten:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>&lt;</span>columns, ...<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>FROM</span> (<span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>&lt;</span>...<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>       )
</span></span><span style=display:flex><span> <span style=color:#66d9ef>WHERE</span> <span style=color:#f92672>&lt;</span>conditions<span style=color:#f92672>&gt;</span>
</span></span></code></pre></div><p>as:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>&lt;</span>columns, ...<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>FROM</span> (<span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>&lt;</span>...<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>       ) sub1
</span></span><span style=display:flex><span> <span style=color:#66d9ef>WHERE</span> <span style=color:#f92672>&lt;</span>conditions<span style=color:#f92672>&gt;</span>
</span></span></code></pre></div><h2 id=implicit-conversions>Implicit conversions
<a class=anchor href=#implicit-conversions>#</a></h2><p>Many implicit conversion to and from a text type have been removed since
PostgreSQL 8.3.</p><p>For instance, one cannot write this type of query:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> depts ( number CHAR(<span style=color:#ae81ff>2</span>), dname VARCHAR(<span style=color:#ae81ff>25</span>) );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>FROM</span> depts <span style=color:#66d9ef>WHERE</span> number <span style=color:#66d9ef>BETWEEN</span> <span style=color:#ae81ff>0</span> <span style=color:#66d9ef>AND</span> <span style=color:#ae81ff>42</span>;
</span></span><span style=display:flex><span><span style=color:#75715e>-- ERROR:  operator does not exist: character &gt;= INTEGER
</span></span></span><span style=display:flex><span><span style=color:#75715e>-- LIGNE 1 : SELECT * FROM depts WHERE number BETWEEN 0 AND 42;
</span></span></span></code></pre></div><p>In order to run this query, one has to explicitly declare the conversion to be
performed:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>FROM</span> depts <span style=color:#66d9ef>WHERE</span> number::INTEGER <span style=color:#66d9ef>BETWEEN</span> <span style=color:#ae81ff>0</span> <span style=color:#66d9ef>AND</span> <span style=color:#ae81ff>42</span>;
</span></span><span style=display:flex><span><span style=color:#75715e>-- or (more SQL compliant)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>FROM</span> depts <span style=color:#66d9ef>WHERE</span> <span style=color:#66d9ef>CAST</span>(id <span style=color:#66d9ef>AS</span> INTEGER) <span style=color:#66d9ef>BETWEEN</span> <span style=color:#ae81ff>0</span> <span style=color:#66d9ef>AND</span> <span style=color:#ae81ff>42</span>;
</span></span></code></pre></div><p>With Oracle, this conversion is implicit (but will mask a potential performance
problem as it will force a type conversion).</p><h2 id=having-and-group-by-clauses>HAVING and GROUP BY clauses
<a class=anchor href=#having-and-group-by-clauses>#</a></h2><p>Even though Oracle&rsquo;s documentation stipulates that the <code>GROUP BY</code> clause precedes
the <code>HAVING</code> clause, Oracle&rsquo;s grammar permits the opposite. Those queries having
<code>HAVING</code> before <code>GROUP BY</code> will have to be corrected.</p><p>This query, for example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>FROM</span> test <span style=color:#66d9ef>HAVING</span> <span style=color:#66d9ef>count</span>(<span style=color:#f92672>*</span>) <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>3</span> <span style=color:#66d9ef>GROUP</span> <span style=color:#66d9ef>BY</span> i;
</span></span></code></pre></div><p>will have to be converted this way to be run in PostgreSQL:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>FROM</span> test <span style=color:#66d9ef>GROUP</span> <span style=color:#66d9ef>BY</span> i <span style=color:#66d9ef>HAVING</span> <span style=color:#66d9ef>count</span>(<span style=color:#f92672>*</span>) <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>3</span>;
</span></span></code></pre></div><p>References:</p><ul><li><a href=https://www.postgresql.org/docs/current/queries-table-expressions.html#QUERIES-GROUP>The GROUP BY and HAVING Clauses</a></li></ul><h2 id=rowid>ROWID
<a class=anchor href=#rowid>#</a></h2><p>In very rare occasions, some SQL queries use Oracle&rsquo;s <code>ROWID</code> column, for instance
to deduplicate records. The <code>ROWID</code> column is the physical location of a record in
a table. PostgreSQL&rsquo;s equivalent is <code>ctid</code>.</p><p>More specifically, Oracle&rsquo;s <code>ROWID</code> is a record&rsquo;s logical address, in the
<code>OOOOOO.FFF.BBBBBB.RRR</code> form, where <code>O</code> is the object&rsquo;s number, <code>F</code> the file, <code>B</code> the
block&rsquo;s number, and <code>R</code> the row&rsquo;s number in this block. The format may vary if
the table is in a <code>BIG FILE TABLESPACE</code>, but the principle stays the same.</p><p>PostgreSQL&rsquo;s <code>ctid</code> contains only the block number and the row&rsquo;s number in this
block. There is no other localisation information. The <code>ctid</code> is only unique
inside a table. Because of that, a query returning <code>ctid</code>s from a partitioned table
may have duplicated. In this peculiar case, one can add the <code>tableoid</code> column
(the table&rsquo;s id in the catalog), which will distinguish between duplicates
coming from different partitions.</p><p>Another difference is that an update doesn&rsquo;t change a record&rsquo;s rowid in Oracle,
while it does change the ctid in PostgreSQL.</p><p>This access method should be avoided as much as possible.</p><p>References:</p><ul><li><a href=https://www.postgresql.org/docs/current/ddl-system-columns.html>System Columns</a></li></ul><h2 id=minus-operator-conversion>Minus operator conversion
<a class=anchor href=#minus-operator-conversion>#</a></h2><p>The <code>MINUS</code> operator has to be converted to <code>EXCEPT</code> for PostgreSQL. The other
set operations <code>UNION</code>, <code>UNION ALL</code>, and <code>INTERSECT</code> don&rsquo;t need any conversion.</p><p>Thus, the following query returns all inventory products which have never been
in a command. It can be written like this for Oracle:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> product_id <span style=color:#66d9ef>FROM</span> inventories
</span></span><span style=display:flex><span>MINUS
</span></span><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> product_id <span style=color:#66d9ef>FROM</span> order_items
</span></span><span style=display:flex><span><span style=color:#66d9ef>ORDER</span> <span style=color:#66d9ef>BY</span> product_id;
</span></span></code></pre></div><p>It will be written this way for PostgreSQL:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> product_id <span style=color:#66d9ef>FROM</span> inventories
</span></span><span style=display:flex><span><span style=color:#66d9ef>EXCEPT</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> product_id <span style=color:#66d9ef>FROM</span> order_items
</span></span><span style=display:flex><span><span style=color:#66d9ef>ORDER</span> <span style=color:#66d9ef>BY</span> product_id;
</span></span></code></pre></div><p>References:</p><ul><li><a href=http://www.postgresql.org/docs/current/static/queries-union.html>Combining Queries (UNION, INTERSECT, EXCEPT)</a></li></ul><h2 id=window-functions>Window Functions
<a class=anchor href=#window-functions>#</a></h2><p>The queries using window functions don&rsquo;t usually need a lot of work.</p><p>Oracle proposes an <code>ORDER SIBLINGS BY</code> clause. The <code>SIBLINGS</code> keyword has no
equivalent and is anyway only used for hierarchy processing, with <code>CONNECT BY</code>.
This kind of query has to be rewritten anyway.</p><p>The <code>PARTITION BY</code> don&rsquo;t need any adaptation, neither the windowing clause
(<code>RANGE ...</code> or <code>ROWS ...</code>).</p><p>Most of Oracle&rsquo;s general usage window functions exist in PostgreSQL. Some
functions still have no equivalent for the moment.</p><ul><li><code>RATIO_TO_REPORT</code> will need to be rewritten (using a division on the sum on
the window).</li><li><code>LISTAGG</code> function will need to be rewritten using <code>array_agg</code> and
<code>array_to_string</code>.</li></ul><p>Please note though that PostgreSQL&rsquo;s extension capabilities make it possible to
write new aggregate and window functions, making it possible to write the
missing functions.</p><p>References:</p><ul><li><a href=https://www.postgresql.org/docs/current/functions-window.html>Window Functions</a></li><li><a href=https://www.postgresql.org/docs/current/tutorial-window.html>Tutorial Window Functions</a></li><li><a href=https://www.postgresql.org/docs/current/sql-expressions.html#SYNTAX-WINDOW-FUNCTIONS>Window Function Calls</a></li><li><a href=https://www.postgresql.org/docs/current/functions-aggregate.html>Aggregate Functions</a></li></ul><h2 id=recursive-cte>Recursive CTE
<a class=anchor href=#recursive-cte>#</a></h2><p>Oracle&rsquo;s grammar makes no difference between a standard CTE and a recursive CTE,
while PostgreSQL does and requires a correct usage of <code>WITH</code> and <code>WITH RECURSIVE</code>. One will need to correct recursive CTE, which should include a
<code>UNION ALL</code> and a reference to the common table expression itself.</p><p>The following query does a very simple recursion:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>WITH</span> recursion (a) <span style=color:#66d9ef>AS</span> (
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>SELECT</span> <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>AS</span> a
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>FROM</span> dual
</span></span><span style=display:flex><span><span style=color:#66d9ef>UNION</span> <span style=color:#66d9ef>ALL</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>SELECT</span> a <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>FROM</span> recursion
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>WHERE</span> a <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>10</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>FROM</span> recursion;
</span></span></code></pre></div><p>Here it is, rewritten for PostgreSQL:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>WITH</span> <span style=color:#66d9ef>RECURSIVE</span> recursion (a) <span style=color:#66d9ef>AS</span> (
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>SELECT</span> <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>AS</span> a
</span></span><span style=display:flex><span><span style=color:#66d9ef>UNION</span> <span style=color:#66d9ef>ALL</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>SELECT</span> a <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>FROM</span> recursion
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>WHERE</span> a <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>10</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>FROM</span> recursion;
</span></span></code></pre></div><p>The <code>WITH</code> clause also proposes some extensions in Oracle, to describe how to
perform the recursion (<em>search_clause</em>) and the loop detection (<em>cycle_clause</em>).
Cycle detection has already been tackled in &ldquo;
<a href=/from-oracle-to-postgresql/hierarchical-querying/>Hierarchical querying</a> " section of this document.</p><p>References:</p><ul><li><a href=https://www.postgresql.org/docs/current/sql-select.html>SELECT</a></li><li><a href=https://www.postgresql.org/docs/current/queries-with.html#QUERIES-WITH-CYCLE>Cycle Detection</a></li></ul><h2 id=merge>MERGE
<a class=anchor href=#merge>#</a></h2><p><code>MERGE</code> command allows to make insertions or updates of tables depending on
whether the rows already exist or not. The typical syntax for the statement
looks like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span>MERGE <span style=color:#66d9ef>INTO</span> destination_table
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>USING</span> source_table <span style=color:#66d9ef>ON</span> (condition)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>WHEN</span> MATCHED <span style=color:#66d9ef>THEN</span> update_clause
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>WHEN</span> <span style=color:#66d9ef>NOT</span> MATCHED <span style=color:#66d9ef>THEN</span> insert_clause;
</span></span></code></pre></div><p>But versions prior to PostgreSQL 15 do not support the syntax <code>MERGE</code> from the
SQL standard. On the other hand, we can emulate this instruction with a <code>INSERT</code>.
It is necessary to distinguish here several cases, according to the presence or
not of <code>WHEN MATCHED</code> and <code>WHEN NOT MATCHED</code> clauses.</p><p>If there is no <code>WHEN NOT MATCHED</code> clause, a simple <code>UPDATE</code> is required:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>UPDATE</span> destination_table
</span></span><span style=display:flex><span>  update_clause
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>USING</span> source_table
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>WHERE</span> join_condition;
</span></span></code></pre></div><p>If there is no <code>WHEN MATCHED</code> clause, using an <code>INSERT</code> on non existing rows is
more relevant:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>INSERT</span> <span style=color:#66d9ef>INTO</span> destination_table
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>SELECT</span> ... <span style=color:#66d9ef>FROM</span> source_table
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>WHERE</span> join_condition
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>ON</span> CONFLICT <span style=color:#66d9ef>DO</span> <span style=color:#66d9ef>NOTHING</span>;
</span></span></code></pre></div><p>If the two clauses <code>WHEN MATCHED</code> and <code>WHEN NOT MATCHED</code> are present, the
translation becomes:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>INSERT</span> <span style=color:#66d9ef>INTO</span> destination_table
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>SELECT</span> ... <span style=color:#66d9ef>FROM</span> source_table
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>WHERE</span> join_condition
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>ON</span> CONFLICT <span style=color:#66d9ef>DO</span> 
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>UPDATE</span> update_clause
</span></span></code></pre></div><p>Sometimes, on Oracle, a <code>DELETE WHERE ...</code> is present after the <code>UPDATE</code> of the
<code>WHEN MATCHED</code> clause. In this case, we can add a simple query <code>DELETE</code> before
or after the <code>INSERT</code>. We can also set this <code>DELETE</code> to inside the <code>INSERT</code>, as
a common table expression (CTE).</p><p>References:</p><ul><li><a href=https://www.postgresql.org/docs/current/sql-insert.html#SQL-ON-CONFLICT>ON CONFLICT Clause</a></li></ul><h2 id=hints-management>Hints management
<a class=anchor href=#hints-management>#</a></h2><p>Oracle&rsquo;s optimizer accepts <em>hints</em>, which make it possible for the DBA to force
the optimizer into using a plan it considers isn&rsquo;t the best. Those hints are
expressed as commends and will be ignored by PostgreSQL, which has no hints.</p><p>Nevertheless, a query making use of a hint should have its execution plan
analyzed carefully, to be sure that it will work with PostgreSQL.</p><p>The plan will be checked with <code>EXPLAIN ANALYZE</code>, which displays both the
estimates of the optimizer and what really occurred during execution. One should
look for a large discrepancy between estimated and real selectivity, for each
node. This will indicate what the optimizer doesn&rsquo;t understand in the query.
Often, this is only the consequence of too imprecise statistics. This can be
corrected in several way.</p><p>First, it&rsquo;s possible to make statistics collection more thorough, by raising the
amount of sampled data. This is controlled by the <code>default_statistics_target</code>
parameter. This can be done globally or per column of each table. A higher value
will make statistics collection consume more resources, and will make query
planning longer, as more statistics will have to be analyzed to make a decision.
The default value of 100 is good for most tables and data sets, so one usually
only change statistics on the very few columns requiring it. This is done with
<code>ALTER TABLE … ALTER COLUMN … SET STATISTICS …</code>. It&rsquo;s also possible to
artificially force the number of distinct values statistic on a column with
<code>ALTER TABLE … SET COLUMN … SET n_distinct = …</code>, as this statistic is quite
difficult to get right for the statistics collector.</p><p>Sometimes, a query rewrite is the solution: queries can be written in ways that
prevent the optimizer from doing good estimations. This is as true for
PostgreSQL as it is for Oracle.</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div class=book-languages tabindex=0 aria-haspopup=true><ul><li class="flex align-center"><img src=/from-oracle-to-postgresql/svg/translate.svg class=book-icon alt=Languages>
English</li></ul><ul class=book-languages-list><li><a href=https://dalibo.github.io/from-oracle-to-postgresql/fr/portage-des-requetes-sql/ class="flex align-center"><img src=/from-oracle-to-postgresql/svg/translate.svg class=book-icon alt=Languages>
French</a></li></ul></div><div><a class="flex align-center" href=https://github.com/dalibo/from-oracle-to-postgresql/commit/0e0e39630a9315928b94eb8adbab6b0771fc83ec title='Last modified by Florent Jardin | November 21, 2022' target=_blank rel=noopener><img src=/from-oracle-to-postgresql/svg/calendar.svg class=book-icon alt=Calendar>
<span>November 21, 2022</span></a></div><div><a class="flex align-center" href=https://github.com/dalibo/from-oracle-to-postgresql/edit/main/content.en/docs/sql/_index.md target=_blank rel=noopener><img src=/from-oracle-to-postgresql/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></div></footer><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#porting-sql-queries>Porting SQL queries</a><ul><li><a href=#dml-statements-compatibility>DML statements compatibility</a></li><li><a href=#subquery-aliases>Subquery aliases</a></li><li><a href=#implicit-conversions>Implicit conversions</a></li><li><a href=#having-and-group-by-clauses>HAVING and GROUP BY clauses</a></li><li><a href=#rowid>ROWID</a></li><li><a href=#minus-operator-conversion>Minus operator conversion</a></li><li><a href=#window-functions>Window Functions</a></li><li><a href=#recursive-cte>Recursive CTE</a></li><li><a href=#merge>MERGE</a></li><li><a href=#hints-management>Hints management</a></li></ul></li></ul></nav></div></aside></main></body></html>